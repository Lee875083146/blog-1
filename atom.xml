<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静默虚空的博客</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/"/>
  <updated>2019-03-22T04:08:13.153Z</updated>
  <id>https://dunwu.github.io/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 中的 JSON 应用</title>
    <link href="https://dunwu.github.io/2019/03/18/programming/java/javalib/java-json/"/>
    <id>https://dunwu.github.io/2019/03/18/programming/java/javalib/java-json/</id>
    <published>2019-03-18T03:10:00.000Z</published>
    <updated>2019-03-22T04:08:13.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-中的-json-应用"><a class="markdownIt-Anchor" href="#java-中的-json-应用"></a> Java 中的 JSON 应用</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#json-%E7%AE%80%E4%BB%8B">JSON 简介</a></li><li><a href="#java-json-%E5%BA%93">Java JSON 库</a></li><li><a href="#fastjson">Fastjson</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0-maven-%E4%BE%9D%E8%B5%96">添加 maven 依赖</a></li><li><a href="#javabean-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">JavaBean 的序列化和反序列化</a></li><li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li></ul></li><li><a href="#jackson">Jackson</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0-maven-%E4%BE%9D%E8%B5%96-1">添加 maven 依赖</a></li><li><a href="#api">API</a></li><li><a href="#%E6%B3%A8%E8%A7%A3-1">注解</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="json-简介"><a class="markdownIt-Anchor" href="#json-简介"></a> JSON 简介</h2><p>JSON（JavaScript Object Notation）是一种基于文本的数据交换格式。几乎所有的编程语言都有很好的库或第三方工具来提供基于 JSON 的 API 支持，因此你可以非常方便地使用任何自己喜欢的编程语言来处理 JSON 数据。</p><p>JSON 建构于两种结构：</p><ul><li>“名称/值”对的集合。不同的语言中，它被理解为<em>对象（object）</em>，纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li><li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li></ul><blockquote><p>扩展阅读：</p><ul><li><p><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a> - 图文并茂介绍 json 数据形式</p></li><li><p><a href="http://tools.ietf.org/html/rfc4627" target="_blank" rel="noopener">json 的 RFC 文档</a></p></li></ul></blockquote><h2 id="java-json-库"><a class="markdownIt-Anchor" href="#java-json-库"></a> Java JSON 库</h2><p>Java 中比较流行的 JSON 库有：</p><ul><li><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">Fastjson</a></li><li><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson</a></li><li><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a></li></ul><h2 id="fastjson"><a class="markdownIt-Anchor" href="#fastjson"></a> Fastjson</h2><p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a> 是阿里巴巴的开源 JSON 解析库。</p><h3 id="添加-maven-依赖"><a class="markdownIt-Anchor" href="#添加-maven-依赖"></a> 添加 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fastjson-api"><a class="markdownIt-Anchor" href="#fastjson-api"></a> Fastjson API</h3><h4 id="javabean-的序列化和反序列化"><a class="markdownIt-Anchor" href="#javabean-的序列化和反序列化"></a> JavaBean 的序列化和反序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = JSON.toJSONString(obj); <span class="comment">//序列化</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO.class); <span class="comment">//反序列化</span></span><br></pre></td></tr></table></figure><h3 id="fastjson-注解"><a class="markdownIt-Anchor" href="#fastjson-注解"></a> Fastjson 注解</h3><h4 id="jsonfield"><a class="markdownIt-Anchor" href="#jsonfield"></a> <code>@JSONField</code></h4><p>可以配置在属性（setter、getter）和字段（必须是 public field）上。</p><blockquote><p>扩展阅读：<a href="https://github.com/alibaba/fastjson/wiki/JSONField" target="_blank" rel="noopener">JSONField 用法</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(name=<span class="string">"ID"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置date序列化和反序列使用yyyyMMdd日期格式</span></span><br><span class="line"><span class="meta">@JSONField</span>(format=<span class="string">"yyyyMMdd"</span>)</span><br><span class="line"><span class="keyword">public</span> Date date1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不序列化</span></span><br><span class="line"><span class="meta">@JSONField</span>(serialize=<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> Date date2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不反序列化</span></span><br><span class="line"><span class="meta">@JSONField</span>(deserialize=<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> Date date3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按ordinal排序</span></span><br><span class="line"><span class="meta">@JSONField</span>(ordinal = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JSONField</span>(ordinal = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> f2;</span><br></pre></td></tr></table></figure><h4 id="jsontype"><a class="markdownIt-Anchor" href="#jsontype"></a> <code>@JSONType</code></h4><ul><li>自定义序列化：<a href="https://github.com/alibaba/fastjson/wiki/JSONType_serializer" target="_blank" rel="noopener">ObjectSerializer</a></li><li>子类型处理：<a href="https://github.com/alibaba/fastjson/wiki/JSONType_seeAlso_cn" target="_blank" rel="noopener">SeeAlso</a></li></ul><p>JSONType.alphabetic 属性: fastjson 缺省时会使用字母序序列化，如果你是希望按照 java fields/getters 的自然顺序序列化，可以配置 JSONType.alphabetic，使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONType</span>(alphabetic = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jackson"><a class="markdownIt-Anchor" href="#jackson"></a> Jackson</h2><p>以下仅列举个人认为比较常用的特性。</p><h3 id="添加-maven-依赖-2"><a class="markdownIt-Anchor" href="#添加-maven-依赖-2"></a> 添加 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="jackson-api"><a class="markdownIt-Anchor" href="#jackson-api"></a> Jackson API</h3><blockquote><p>扩展阅读：更多 API 使用细节可以参考 <a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind 官方说明</a></p></blockquote><h4 id="javabean-的序列化和反序列化-2"><a class="markdownIt-Anchor" href="#javabean-的序列化和反序列化-2"></a> JavaBean 的序列化和反序列化</h4><p>反序列化示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">MyValue value = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"data.json"</span>), MyValue.class);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://some.com/api/entry.json"</span>), MyValue.class);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="string">"&#123;\"name\":\"Bob\", \"age\":13&#125;"</span>, MyValue.class);</span><br></pre></td></tr></table></figure><p>序列化示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"result.json"</span>), myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line"><span class="keyword">byte</span>[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure><h4 id="容器的序列化和反序列化"><a class="markdownIt-Anchor" href="#容器的序列化和反序列化"></a> 容器的序列化和反序列化</h4><figure class="highlight plain"><figcaption><span>扩展阅读：更多 API 使用细节可以参考  [jackson-databind 官方说明](https://github.com/FasterXML/jackson-databind)java</span></figcaption><table><tr><td class="code"><pre><span class="line">Person p = new Person(&quot;Tom&quot;, 20);</span><br><span class="line">Person p2 = new Person(&quot;Jack&quot;, 22);</span><br><span class="line">Person p3 = new Person(&quot;Mary&quot;, 18);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = new LinkedList&lt;&gt;();</span><br><span class="line">persons.add(p);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;persons&quot;, persons);</span><br><span class="line"></span><br><span class="line">String json = null;</span><br><span class="line">try &#123;</span><br><span class="line">json = mapper.writeValueAsString(map);</span><br><span class="line">&#125; catch (JsonProcessingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jackson-注解"><a class="markdownIt-Anchor" href="#jackson-注解"></a> Jackson 注解</h3><blockquote><p>扩展阅读：更多注解使用细节可以参考 <a href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" target="_blank" rel="noopener">jackson-annotations 官方说明</a></p></blockquote><h4 id="jsonproperty"><a class="markdownIt-Anchor" href="#jsonproperty"></a> <code>@JsonProperty</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String _name;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// without annotation, we'd get "theName", but we want "name":</span></span><br><span class="line">   <span class="meta">@JsonProperty</span>(<span class="string">"name"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getTheName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// note: it is enough to add annotation on just getter OR setter;</span></span><br><span class="line">   <span class="comment">// so we can omit it here</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheName</span><span class="params">(String n)</span> </span>&#123; _name = n; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonignoreproperties-和-jsonignore"><a class="markdownIt-Anchor" href="#jsonignoreproperties-和-jsonignore"></a> <code>@JsonIgnoreProperties</code> 和 <code>@JsonIgnore</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// means that if we see "foo" or "bar" in JSON, they will be quietly skipped</span></span><br><span class="line"><span class="comment">// regardless of whether POJO has such properties</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123; <span class="string">"foo"</span>, <span class="string">"bar"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">   <span class="comment">// will not be written as JSON; nor assigned from JSON:</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">public</span> String internal;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// no annotation, public field is read/written normally</span></span><br><span class="line">   <span class="keyword">public</span> String external;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; _code = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// note: will also be ignored because setter has annotation!</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsoncreator"><a class="markdownIt-Anchor" href="#jsoncreator"></a> <code>@JsonCreator</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonCreator</span> <span class="comment">// constructor can be public, private, whatever</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CtorBean</span><span class="params">(@JsonProperty(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">    @<span class="title">JsonProperty</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonpropertyorder"><a class="markdownIt-Anchor" href="#jsonpropertyorder"></a> <code>@JsonPropertyOrder</code></h4><p>alphabetic 设为 true 表示，json 字段按自然顺序排列，默认为 false。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@JsonPropertyOrder(alphabetic = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JacksonAnnotationBean</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a></li><li><a href="http://tools.ietf.org/html/rfc4627" target="_blank" rel="noopener">json 的 RFC 文档</a></li><li><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a></li><li><a href="https://github.com/FasterXML/jackson-docs" target="_blank" rel="noopener">jackson 官方文档</a></li><li><a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind</a></li><li><a href="https://kimmking.github.io/2017/06/06/json-best-practice/" target="_blank" rel="noopener">JSON 最佳实践</a></li><li><a href="https://www.jianshu.com/p/8b428e1d1564" target="_blank" rel="noopener">【简明教程】JSON</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-中的-json-应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-中的-json-应用&quot;&gt;&lt;/a&gt; Java 中的 JSON 应用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;
      
    
    </summary>
    
      <category term="programming" scheme="https://dunwu.github.io/categories/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/categories/programming/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/categories/programming/java/javalib/"/>
    
    
      <category term="programming" scheme="https://dunwu.github.io/tags/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/tags/javalib/"/>
    
      <category term="json" scheme="https://dunwu.github.io/tags/json/"/>
    
      <category term="fastjson" scheme="https://dunwu.github.io/tags/fastjson/"/>
    
      <category term="jackson" scheme="https://dunwu.github.io/tags/jackson/"/>
    
  </entry>
  
  <entry>
    <title>Java 常用工具类</title>
    <link href="https://dunwu.github.io/2019/03/14/programming/java/javacore/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://dunwu.github.io/2019/03/14/programming/java/javacore/Java常用工具类/</id>
    <published>2019-03-14T05:02:00.000Z</published>
    <updated>2019-03-22T04:08:12.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-常用工具类"><a class="markdownIt-Anchor" href="#java-常用工具类"></a> Java 常用工具类</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p>⌨️ 本文中的示例代码已归档到：「<a href="https://github.com/dunwu/javacore/tree/master/codes/basics/src/main/java/io/github/dunwu/javacore/tool" target="_blank" rel="noopener">javacore</a>」</p><p>并发、IO、容器的工具类不会在本文提及，后面会有专题一一道来。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a><ul><li><a href="#string">String</a></li><li><a href="#stringbuffer">StringBuffer</a></li><li><a href="#stringbuilder">StringBuilder</a></li></ul></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">日期时间</a><ul><li><a href="#date">Date</a></li><li><a href="#simpledateformat">SimpleDateFormat</a></li><li><a href="#calendar">Calendar</a></li></ul></li><li><a href="#%E6%95%B0%E5%AD%A6">数学</a><ul><li><a href="#number">Number</a></li><li><a href="#math">Math</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><h3 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h3><h3 id="stringbuilder"><a class="markdownIt-Anchor" href="#stringbuilder"></a> StringBuilder</h3><h2 id="日期时间"><a class="markdownIt-Anchor" href="#日期时间"></a> 日期时间</h2><h3 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h3><h3 id="simpledateformat"><a class="markdownIt-Anchor" href="#simpledateformat"></a> SimpleDateFormat</h3><h3 id="calendar"><a class="markdownIt-Anchor" href="#calendar"></a> Calendar</h3><h2 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h2><h3 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h3><h3 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h3><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java 编程思想</a></li><li><a href="https://book.douban.com/subject/3146174/" target="_blank" rel="noopener">JAVA 核心技术（卷 1）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-常用工具类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-常用工具类&quot;&gt;&lt;/a&gt; Java 常用工具类&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://github.
      
    
    </summary>
    
      <category term="programming" scheme="https://dunwu.github.io/categories/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/categories/programming/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/categories/programming/java/javacore/"/>
    
    
      <category term="programming" scheme="https://dunwu.github.io/tags/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/tags/javacore/"/>
    
  </entry>
  
  <entry>
    <title>Electron</title>
    <link href="https://dunwu.github.io/2019/03/14/frontend/electron/"/>
    <id>https://dunwu.github.io/2019/03/14/frontend/electron/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-03-22T04:08:11.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="electron"><a class="markdownIt-Anchor" href="#electron"></a> Electron</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:2 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%85%A5%E9%97%A8">入门</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Electron 是什么？</p><p>Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 等 Web 技术构建跨平台的应用（兼容 Mac, Windows 和 Linux）。</p><h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2><p>快速启动 应用程序，看看 Electron 是如何运转的：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆示例项目的仓库</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/electron/electron-quick-<span class="literal">start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入这个仓库</span></span><br><span class="line">$ cd electron-quick-<span class="literal">start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖并运行</span></span><br><span class="line">$ npm install &amp;&amp; npm <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/electron/electron" target="_blank" rel="noopener">electron</a></li><li><a href="https://electronjs.org/" target="_blank" rel="noopener">electron 官方文档</a></li><li><a href="https://github.com/sindresorhus/awesome-electron" target="_blank" rel="noopener">awesome-electron</a></li><li><a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">electron-quick-start</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;electron&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#electron&quot;&gt;&lt;/a&gt; Electron&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础语法特性</title>
    <link href="https://dunwu.github.io/2019/03/10/programming/java/javacore/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/"/>
    <id>https://dunwu.github.io/2019/03/10/programming/java/javacore/Java基础语法特性/</id>
    <published>2019-03-10T14:28:00.000Z</published>
    <updated>2019-03-22T04:08:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-基础语法特性"><a class="markdownIt-Anchor" href="#java-基础语法特性"></a> Java 基础语法特性</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6">变量修饰符</a></li></ul></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6">操作符</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">控制语句</a></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li></ul><!-- /TOC --><h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2><p>空白行，或者注释的内容，都会被 Java 编译器忽略掉。</p><p>Java 支持多种注释方式，下面的示例展示了各种注释的使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JavaDoc 注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">        <span class="comment">/* 多行注释：</span></span><br><span class="line"><span class="comment">           1. 注意点a</span></span><br><span class="line"><span class="comment">           2. 注意点b</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2><p>（1）Java 中的数据类型有两类：</p><ul><li>值类型（<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>boolean</code>）</li><li>引用类型（除值类型以外，都是引用类型，包括 <code>String</code>、数组）</li></ul><p>（2）Java 中，数据类型转换有两种方式：</p><ul><li>自动换行</li><li>强制转换</li></ul><p>强制转换使用括号 <code>()</code> 。</p><p>基础数据类型可以自动转换，转换原则如下：</p><ul><li>由小数据转换为大数据</li><li>转换前后的数据类型要兼容</li><li>整型类型和浮点型进行计算后，结果会转为浮点类型</li></ul><p>（3）包装类有如下种类：</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">B<span class="function"><span class="title">yte</span> &lt;-&gt;</span> byte</span><br><span class="line">S<span class="function"><span class="title">hort</span> &lt;-&gt;</span> short</span><br><span class="line">I<span class="function"><span class="title">nteger</span> &lt;-&gt;</span> int</span><br><span class="line">L<span class="function"><span class="title">ong</span> &lt;-&gt;</span> long</span><br><span class="line">F<span class="function"><span class="title">loat</span> &lt;-&gt;</span> float</span><br><span class="line">D<span class="function"><span class="title">ouble</span> &lt;-&gt;</span> double</span><br><span class="line">C<span class="function"><span class="title">haracter</span> &lt;-&gt;</span> char</span><br><span class="line">B<span class="function"><span class="title">oolean</span> &lt;-&gt;</span> <span class="keyword">boolean</span></span><br></pre></td></tr></table></figure><p>（4）什么是装箱、拆箱</p><ul><li>**<code>装箱</code>（boxing）是将值类型转换为引用类型。**例如：<code>int</code> 转 <code>Integer</code><ul><li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li></ul></li><li>**<code>拆箱</code>（unboxing）是将引用类型转换为值类型。**例如：<code>Integer</code> 转 <code>int</code><ul><li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li></ul></li></ul><p>（5）装箱、拆箱的应用场景</p><ul><li>含类型为 <code>Object</code> 参数的方法</li><li>非泛型的容器</li><li>当 <code>==</code> 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。</li></ul><p>（6）装箱、拆箱的应用注意点</p><ul><li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li><li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li></ul><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md" target="_blank" rel="noopener">深入理解 Java 基本数据类型</a></p></blockquote><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><p>Java 支持的变量类型有：</p><ul><li><code>局部变量</code> - 类方法中的变量。</li><li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li><li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li></ul><p>特性对比：</p><table><thead><tr><th>局部变量</th><th>实例变量（也叫成员变量）</th><th>类变量（也叫静态变量）</th></tr></thead><tbody><tr><td>局部变量声明在方法、构造方法或者语句块中。</td><td>实例变量声明在方法、构造方法和语句块之外。</td><td>类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。</td></tr><tr><td>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</td><td>实例变量在对象创建的时候创建，在对象被销毁的时候销毁。</td><td>类变量在第一次被访问时创建，在程序结束时销毁。</td></tr><tr><td>局部变量没有默认值，所以必须经过初始化，才可以使用。</td><td>实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</td><td>类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</td></tr><tr><td>对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。</td><td>实例变量存储在堆。</td><td>类变量存储在静态存储区。</td></tr><tr><td>访问修饰符不能用于局部变量。</td><td>访问修饰符可以用于实例变量。</td><td>访问修饰符可以用于类变量。</td></tr><tr><td>局部变量只在声明它的方法、构造方法或者语句块中可见。</td><td>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。</td><td>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</td></tr><tr><td></td><td>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</td><td>静态变量可以通过：ClassName.VariableName 的方式访问。</td></tr><tr><td></td><td></td><td>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</td></tr><tr><td></td><td></td><td>类变量除了被声明为常量外很少使用。</td></tr></tbody></table><h3 id="变量修饰符"><a class="markdownIt-Anchor" href="#变量修饰符"></a> 变量修饰符</h3><ul><li>访问级别修饰符<ul><li>如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）</li></ul></li><li>静态修饰符<ul><li>如果变量是类变量，需要添加 static 修饰</li></ul></li><li>final<ul><li>如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。</li></ul></li></ul><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1552475700514.png"></div><p>（1）数组特性</p><ul><li><strong>Java 中，数组是一种引用类型。</strong></li><li><strong>Java 中，数组是用来存储固定大小的同类型元素。</strong></li><li><strong>数组的定义和使用需要通过方括号 <code>[]</code>。</strong></li></ul><p>（2）数组和容器</p><ul><li><p>大多数情况下，应该选择容器存储数据。</p></li><li><p><strong>数组的效率要高于容器</strong></p></li><li><p><strong>数组可以持有值类型，而容器则不能</strong></p></li></ul><p>（3）<strong>Java 数组的本质是对象</strong>。</p><p>（4）Java 数组和内存</p><ul><li>数组对象（数组指针）存储在栈中。</li><li>数组元素值存储在堆中。</li></ul><p>（5）声明数组有两种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1; <span class="comment">// 推荐风格</span></span><br><span class="line"><span class="keyword">int</span> arr2[]; <span class="comment">// 效果相同</span></span><br></pre></td></tr></table></figure><p>（6）创建数组有两种方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// 指定数组维度</span></span><br><span class="line"><span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// 不指定数组维度</span></span><br></pre></td></tr></table></figure><p><strong>Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可</strong>。</p><p><strong>数组过大，可能会导致栈溢出</strong>。超过一定数值，甚至编译器就会报错。</p><p>（7）<strong>Java 中，可以通过在 <code>[]</code> 中指定下标，访问数组元素，下标位置从 0 开始。</strong></p><p>（8）数组可以作为函数的入参或返回值。</p><p>（9）多维数组可视为数组的数组。</p><p>（10）Arrays 类是一个很有用的数组工具类。</p><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">深入理解 Java 数组</a></p></blockquote><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h2><p>Java 中支持的操作符类型如下：</p><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1552382318465.png"></div><br></p><blockquote><p>👉 扩展阅读：<a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">Java 运算符</a></p></blockquote><h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2><p>Java 中控制语句分为三大类：循环语句、选择语句、中断语句</p><ul><li>循环<ul><li><code>while</code> - 只要条件成立，则一直循环。</li><li><code>do...while</code> - do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</li><li><code>for</code> - 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。执行一次循环后，更新循环控制变量。再次检测布尔表达式。循环执行上面的过程。</li><li><code>foreach</code> - 声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li></ul></li><li>选择<ul><li><code>if...else-if...else</code> - if 语句至多有 1 个 else 语句，else 语句在所有的 elseif 语句之后。if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li><li><code>switch</code> - 判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</li></ul></li><li>中断<ul><li><code>break</code> - 跳出循环体，继续执行循环外的函数体。</li><li><code>continue</code> - 跳出本次循环继续下一次循环。</li><li><code>return</code> - 跳出整个函数体，函数体后面的部分不再执行。</li></ul></li></ul><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.md" target="_blank" rel="noopener">Java 控制语句</a></p></blockquote><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><p>（1）<strong><code>Throwable</code> 是 Java 语言中所有错误（<code>Error</code>）和异常（<code>Exception</code>）的超类。</strong></p><p>（2）<code>Error</code> 是 <code>Throwable</code> 的一个子类。**<code>Error</code> 表示合理的应用程序不应该尝试捕获的严重问题。**大多数此类错误都是异常情况。<strong>编译器不会检查 <code>Error</code>。</strong></p><p>（3）<code>Exception</code> 是 <code>Throwable</code> 的一个子类。**<code>Exception</code> 表示合理的应用程序可能想要捕获的条件。编译器会检查 <code>Exception</code> 异常。**此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p><p>（4）<code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。**编译器不会检查 <code>RuntimeException</code> 异常。**当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p><p>（5）<strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p><p>（6）如果想在程序中明确地引发异常，则需要用到 <code>throw</code> 和 <code>throws</code> 。</p><p>（7）<strong>使用 try 和 catch 关键字可以捕获异常。</strong></p><ul><li><code>try</code> - <strong><code>try</code> 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</strong></li><li><code>catch</code> - <code>catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</li><li><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong><code>try catch</code> 语句后不一定非要<code>finally</code> 语句。<code>finally</code> 常用于这样的场景：由于<code>finally</code> 语句块总是会被执行，所以那些在 <code>try</code> 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在<code>finally</code> 语句块中释放资源。</li></ul><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%BC%82%E5%B8%B8.md" target="_blank" rel="noopener">深入理解 Java 异常</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-基础语法特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-基础语法特性&quot;&gt;&lt;/a&gt; Java 基础语法特性&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://gith
      
    
    </summary>
    
      <category term="programming" scheme="https://dunwu.github.io/categories/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/categories/programming/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/categories/programming/java/javacore/"/>
    
    
      <category term="programming" scheme="https://dunwu.github.io/tags/programming/"/>
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/tags/javacore/"/>
    
  </entry>
  
  <entry>
    <title>Title</title>
    <link href="https://dunwu.github.io/2019/03/08/design/architecture/README/"/>
    <id>https://dunwu.github.io/2019/03/08/design/architecture/README/</id>
    <published>2019-03-08T05:16:53.000Z</published>
    <updated>2019-03-22T04:08:11.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h1><p>架构设计是为业务服务，<strong>脱离业务实际的架构设计都是纸上谈兵</strong>。</p><p>架构设计需要根据架构师自身的经验，在实现业务功能、性能、扩展性、系统复杂度等维度上综合考量以及权衡。而架构设计的经验需要架构师不断的学习、不断的积累。性能、扩展性、系统复杂度等方面有很多个专题，有必要针对每个专题由浅入深的去理解、掌握。</p><h2 id="专题"><a class="markdownIt-Anchor" href="#专题"></a> 专题</h2><h2 id="如何设计"><a class="markdownIt-Anchor" href="#如何设计"></a> 如何设计</h2><h3 id="第一步需求分析"><a class="markdownIt-Anchor" href="#第一步需求分析"></a> 第一步：需求分析</h3><p>需求分析阶段，要做的就是<strong>分析使用场景，约束和假设</strong>。</p><p>这个阶段，应该以审视的角度，不断提问、求证，以挖掘用户真实的需求。</p><ul><li>系统是什么？系统有什么功能？</li><li>谁是系统的用户群体？用户群体的规模是多大？</li><li>系统的输入输出分别是什么？</li><li>系统希望处理多少数据？</li><li>系统希望每秒钟处理多少请求？</li><li>系统希望的读写比率？</li></ul><h3 id="第二步概要设计"><a class="markdownIt-Anchor" href="#第二步概要设计"></a> 第二步：概要设计</h3><p>创造一个高层级的设计</p><h3 id="第三步详细设计"><a class="markdownIt-Anchor" href="#第三步详细设计"></a> 第三步：详细设计</h3><ul><li>数据库选型：SQL 还是 NOSQL</li><li>数据库模型</li><li>API 和面向对象设计</li></ul><h3 id="第四步扩展设计"><a class="markdownIt-Anchor" href="#第四步扩展设计"></a> 第四步：扩展设计</h3><ul><li>负载均衡</li><li>水平扩展</li><li>缓存</li><li>数据库分片</li><li>消息队列</li></ul><h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>文章<ul><li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">系统设计入门</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;架构设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#架构设计&quot;&gt;&lt;/a&gt; 架构设计&lt;/h1&gt;
&lt;p&gt;架构设计是为业务服务，&lt;strong&gt;脱离业务实际的架构设计都是纸上谈兵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;架构设计需要根据架构师自
      
    
    </summary>
    
      <category term="design" scheme="https://dunwu.github.io/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>分布式技术面试题</title>
    <link href="https://dunwu.github.io/2019/03/08/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://dunwu.github.io/2019/03/08/design/architecture/分布式技术面试题/</id>
    <published>2019-03-08T03:35:31.770Z</published>
    <updated>2019-03-22T04:08:11.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式技术面试题"><a class="markdownIt-Anchor" href="#分布式技术面试题"></a> 分布式技术面试题</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">1. 分布式缓存</a><ul><li><a href="#11-redis-%E6%9C%89%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF">1.1. Redis 有什么数据类型？分别用于什么场景？</a></li><li><a href="#12-redis-%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.2. Redis 的主从复制是如何实现的？</a></li><li><a href="#13-redis-%E7%9A%84-key-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84">1.3. Redis 的 key 是如何寻址的？</a></li><li><a href="#14-redis-%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.4. Redis 的集群模式是如何实现的？</a></li><li><a href="#15-redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81zookeeper-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%AF%94%E8%BE%83%E4%BA%8C%E8%80%85%E4%BC%98%E5%8A%A3">1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</a></li><li><a href="#16-redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</a></li><li><a href="#17-redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">1.7. Redis 过期策略有哪些？</a></li><li><a href="#18-redis-%E5%92%8C-memcached-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1.8. Redis 和 Memcached 有什么区别？</a></li><li><a href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-redis-%E6%80%A7%E8%83%BD%E5%8F%8D%E8%80%8C%E4%BC%98%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84-memcached">1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</a></li></ul></li><li><a href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq">2. 分布式消息队列（MQ）</a><ul><li><a href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-mq">2.1. 为什么使用 MQ？</a></li><li><a href="#22-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-mq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">2.2. 如何保证 MQ 的高可用？</a></li><li><a href="#23-mq-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98">2.3. MQ 有哪些常见问题？如何解决这些问题？</a></li><li><a href="#24-kafka-activemq-rabbitmq-rocketmq-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9">2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</a></li></ul></li><li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1rpc">3. 分布式服务（RPC）</a><ul><li><a href="#31-dubbo-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">3.1. Dubbo 的实现过程？</a></li><li><a href="#32-dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">3.2. Dubbo 负载均衡策略有哪些？</a></li><li><a href="#33-dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5-">3.3. Dubbo 集群容错策略 ？</a></li><li><a href="#34-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5">3.4. 动态代理策略？</a></li><li><a href="#35-dubbo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AEhessianhessian-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</a></li><li><a href="#36-protoco-buffer-%E6%98%AF%E4%BB%80%E4%B9%88">3.6. Protoco Buffer 是什么？</a></li><li><a href="#37-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8C%82%E4%BA%86%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E9%80%9A%E4%BF%A1%E5%90%97">3.7. 注册中心挂了可以继续通信吗？</a></li><li><a href="#38-zookeeper-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88zookeeper-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</a></li><li><a href="#39-netty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8niobioaio-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</a></li><li><a href="#310-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%8B%86%E5%88%86%E4%B8%8D%E7%94%A8-dubbo-%E5%8F%AF%E4%BB%A5%E5%90%97">3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</a></li><li><a href="#311-dubbo-%E5%92%8C-thrift-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.11. Dubbo 和 Thrift 有什么区别？</a></li></ul></li></ul><!-- /TOC --><h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2><h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景？</h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素<br> 读取单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的？</h3><ol><li>从服务器连接主服务器，发送 SYNC 命令；</li><li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ol><h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的？</h3><h4 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h4><p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p><ul><li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li><li>redisDb.dict 存储着该库所有的键值对数据。</li><li>redisDb.expires 保存着每一个键的过期时间。</li></ul><p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p><p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p><p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p><h4 id="寻址-key-的步骤"><a class="markdownIt-Anchor" href="#寻址-key-的步骤"></a> 寻址 key 的步骤</h4><ol><li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li><li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li><li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li><li>根据哈希值与当前字典计算哈希表的索引值。</li><li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li><li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li></ol><h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p><p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p><h4 id="redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#redis-cluster-节点分配"></a> Redis Cluster 节点分配</h4><p>Redis Cluster 特点：</p><ol><li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li><li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。</li><li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li></ol><h4 id="redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#redis-cluster-主从模式"></a> Redis Cluster 主从模式</h4><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p><p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p><h4 id="redis-sentinel"><a class="markdownIt-Anchor" href="#redis-sentinel"></a> Redis Sentinel</h4><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p><ul><li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p><p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p><p>假设集群仅仅部署 2 个节点</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p><h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3><p>分布式锁的三种实现：</p><ul><li>基于数据库实现分布式锁；</li><li>基于缓存（Redis 等）实现分布式锁；</li><li>基于 Zookeeper 实现分布式锁；</li></ul><h4 id="数据库实现"><a class="markdownIt-Anchor" href="#数据库实现"></a> 数据库实现</h4><h4 id="redis-实现"><a class="markdownIt-Anchor" href="#redis-实现"></a> Redis 实现</h4><ol><li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol><h4 id="zookeeper-实现"><a class="markdownIt-Anchor" href="#zookeeper-实现"></a> ZooKeeper 实现</h4><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h4 id="实现对比"><a class="markdownIt-Anchor" href="#实现对比"></a> 实现对比</h4><p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br>但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3><h4 id="rdb-快照snapshot"><a class="markdownIt-Anchor" href="#rdb-快照snapshot"></a> RDB 快照（snapshot）</h4><p>将存在于某一时刻的所有数据都写入到硬盘中。</p><h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5><p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p><ul><li>Redis 创建一个子进程。</li><li>子进程将数据集写入到一个临时快照文件中。</li><li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li></ul><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5><ul><li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li><li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li><li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li><li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li></ul><h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5><ul><li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li><li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li></ul><h4 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h4><p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p><h4 id="aof-的原理"><a class="markdownIt-Anchor" href="#aof-的原理"></a> AOF 的原理</h4><ul><li>Redis 创建一个子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ul><h4 id="aof-的优点"><a class="markdownIt-Anchor" href="#aof-的优点"></a> AOF 的优点</h4><ul><li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li><li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li></ul><h4 id="aof-的缺点"><a class="markdownIt-Anchor" href="#aof-的缺点"></a> AOF 的缺点</h4><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li></ul><h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3><ul><li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li><li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li><li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li><li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li><li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li><li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li></ul><h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3><p>两者都是非关系型内存键值数据库。有以下主要不同：</p><p><strong>数据类型</strong></p><ul><li>Memcached 仅支持字符串类型；</li><li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li></ul><p><strong>数据持久化</strong></p><ul><li>Memcached 不支持持久化；</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li></ul><p><strong>分布式</strong></p><ul><li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul><p><strong>内存管理机制</strong></p><ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li></ul><h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3><p>Redis 快速的原因：</p><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO</li></ol><p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p><h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2><h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3><h4 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h4><ol><li>将所有 Broker 和待分配的 Partition 排序</li><li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li><li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li></ol><h4 id="选举主服务器"><a class="markdownIt-Anchor" href="#选举主服务器"></a> 选举主服务器</h4><h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p><ol><li>消息的顺序问题</li><li>消息的重复问题</li></ol><h4 id="消息的顺序问题"><a class="markdownIt-Anchor" href="#消息的顺序问题"></a> 消息的顺序问题</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p><p>解决方案：</p><p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li></ul><p>（2）通过合理的设计或者将问题分解来规避。</p><ul><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序</li></ul><p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p><h4 id="消息的重复问题"><a class="markdownIt-Anchor" href="#消息的重复问题"></a> 消息的重复问题</h4><p>造成消息重复的根本原因是：网络不可达。</p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p><h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3><p><br><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><br></p><h2 id="3-分布式服务rpc"><a class="markdownIt-Anchor" href="#3-分布式服务rpc"></a> 3. 分布式服务（RPC）</h2><h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo基本架构.png" width="500"></div><p>节点角色：</p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>调用关系：</p><ol><li>务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3><h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li></ul><h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3><p><br><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg"></div><br></p><ul><li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</li><li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</li><li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3><p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p><p><br><div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"></div><br></p><p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p><h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3><ol><li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li><li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li><li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li><li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li><li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li></ol><p>Hessian 序列化与 Java 默认的序列化区别？</p><p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p><ol><li>Hessian 支持跨语言串行</li><li>比 java 序列化具有更好的性能和易用性</li><li>支持的语言比较多</li></ol><h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3><p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><ol><li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li><li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol><h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p><h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3><p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/zookeeper-service.png"></div><ol><li>每个 Server 在内存中存储了一份数据；</li><li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li><li>Leader 负责处理数据更新等操作（Zab 协议）；</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li></ol><h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3><p>Netty 是一个“网络通讯框架”。</p><p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p><p><br><div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"></div><br></p><blockquote><p>参考：<a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md" target="_blank" rel="noopener">https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md</a></p></blockquote><p>IO 的方式通常分为几种：</p><ul><li>同步阻塞的 BIO</li><li>同步非阻塞的 NIO</li><li>异步非阻塞的 AIO</li></ul><p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p><p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p><blockquote><p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p></blockquote><h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3><p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p><p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p><p><br><div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"></div><br></p><p>是否使用服务依据实际业务场景来决定。</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3><ul><li>Thrift 是跨语言的 RPC 框架。</li><li>Dubbo 支持服务治理，而 Thrift 不支持。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式技术面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式技术面试题&quot;&gt;&lt;/a&gt; 分布式技术面试题&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%
      
    
    </summary>
    
      <category term="design" scheme="https://dunwu.github.io/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/tags/architecture/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/tags/distributed/"/>
    
      <category term="interview" scheme="https://dunwu.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/07/programming/java/javaweb/tools/README/"/>
    <id>https://dunwu.github.io/2019/03/07/programming/java/javaweb/tools/README/</id>
    <published>2019-03-07T10:18:42.486Z</published>
    <updated>2019-03-22T04:08:14.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式"><a class="markdownIt-Anchor" href="#分布式"></a> 分布式</h1><blockquote><p>Java Web 领域常用工具。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式&quot;&gt;&lt;/a&gt; 分布式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Java Web 领域常用工具。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/spring/web/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/spring/web/README/</id>
    <published>2019-03-06T08:38:13.369Z</published>
    <updated>2019-03-22T04:08:14.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web"><a class="markdownIt-Anchor" href="#web"></a> Web</h1><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="spring-mvc-introduction.html">SpringMVC 简介</a></li><li><a href="spring-and-websocket.html">Spring 和 WebSocket</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#web&quot;&gt;&lt;/a&gt; Web&lt;/h1&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/spring/introduction/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/spring/introduction/README/</id>
    <published>2019-03-06T08:38:13.347Z</published>
    <updated>2019-03-22T04:08:14.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介introduction"><a class="markdownIt-Anchor" href="#简介introduction"></a> 简介（introduction）</h1><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介introduction&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介introduction&quot;&gt;&lt;/a&gt; 简介（introduction）&lt;/h1&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anch
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/spring/integration/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/spring/integration/README/</id>
    <published>2019-03-06T08:38:13.311Z</published>
    <updated>2019-03-22T04:08:14.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集成integration"><a class="markdownIt-Anchor" href="#集成integration"></a> 集成（integration）</h1><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="spring-and-dubbo.html">Spring 集成 Dubbo</a></li><li><a href="spring-and-cache.html">Spring 集成缓存</a></li><li><a href="spring-and-scheduler.html">Spring 集成调度器</a></li><li><a href="lombok.html">Lombok 使用小结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集成integration&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集成integration&quot;&gt;&lt;/a&gt; 集成（integration）&lt;/h1&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot;
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/spring/data/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/spring/data/README/</id>
    <published>2019-03-06T08:38:13.263Z</published>
    <updated>2019-03-22T04:08:14.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据data"><a class="markdownIt-Anchor" href="#数据data"></a> 数据（data）</h1><h2 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h2><ul><li><p>Spring 的数据访问策略</p></li><li><p>使用 JDBC 访问数据</p></li><li><p>使用 ORM 访问数据（待补充）</p></li><li><p>事务管理（待补充）</p></li></ul><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据data&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据data&quot;&gt;&lt;/a&gt; 数据（data）&lt;/h1&gt;
&lt;h2 id=&quot;内容&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容&quot;&gt;&lt;/a&gt; 内容&lt;/
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/spring/appendix/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/spring/appendix/README/</id>
    <published>2019-03-06T08:38:13.221Z</published>
    <updated>2019-03-22T04:08:14.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录appendix"><a class="markdownIt-Anchor" href="#附录appendix"></a> 附录（appendix）</h1><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;附录appendix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#附录appendix&quot;&gt;&lt;/a&gt; 附录（appendix）&lt;/h1&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javaweb/standalone/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javaweb/standalone/README/</id>
    <published>2019-03-06T08:38:13.138Z</published>
    <updated>2019-03-22T04:08:14.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单机"><a class="markdownIt-Anchor" href="#单机"></a> 单机</h1><blockquote><p>Web 领域的单机技术</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单机&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单机&quot;&gt;&lt;/a&gt; 单机&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Web 领域的单机技术&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javaweb/javaee/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javaweb/javaee/README/</id>
    <published>2019-03-06T08:38:12.988Z</published>
    <updated>2019-03-22T04:08:14.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javaee"><a class="markdownIt-Anchor" href="#javaee"></a> JavaEE</h1><blockquote><p><a href="http://www.oracle.com/technetwork/java/javaee/overview/index.html" target="_blank" rel="noopener">JavaEE</a> 即 Java 的企业级应用程序版本。这个版本以前称为 J2EE。能够帮助我们开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。</p><p>JavaEE 是在 JavaSE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的 SOA 和 Web 3.0 应用程序。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;javaee&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#javaee&quot;&gt;&lt;/a&gt; JavaEE&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/maven/README/</id>
    <published>2019-03-06T08:38:12.757Z</published>
    <updated>2019-03-22T04:08:13.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven"><a class="markdownIt-Anchor" href="#maven"></a> Maven</h1><ul><li><a href="maven-quickstart.md">Maven 快速指南</a></li><li><a href="maven-pom.md">Maven 之 pom.xml 详解</a></li><li><a href="maven-settings.md">Maven 之 settings.xml 详解</a></li><li><a href="maven-action.md">Maven 常见问题和最佳实践</a></li><li><a href="maven-deploy.md">发布项目到 Maven 中央仓库</a></li><li><a href="nexus.md">部署并使用 Nexus 作为 Maven 私服</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;maven&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#maven&quot;&gt;&lt;/a&gt; Maven&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;maven-quickstart.md&quot;&gt;Maven 快速指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/build/README/</id>
    <published>2019-03-06T08:38:12.720Z</published>
    <updated>2019-03-22T04:08:13.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建工具"><a class="markdownIt-Anchor" href="#构建工具"></a> 构建工具</h1><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><h3 id="maven"><a class="markdownIt-Anchor" href="#maven"></a> Maven</h3><ul><li><a href="maven/maven-quickstart.md">Maven 快速指南</a></li><li><a href="maven/maven-pom.md">Maven 之 pom.xml 详解</a></li><li><a href="maven/maven-settings.md">Maven 之 settings.xml 详解</a></li><li><a href="maven/maven-action.md">Maven 常见问题和最佳实践</a></li><li><a href="maven/maven-deploy.md">发布项目到 Maven 中央仓库</a></li><li><a href="maven/nexus.md">部署并使用 Nexus 作为 Maven 私服</a></li></ul><h3 id="ant"><a class="markdownIt-Anchor" href="#ant"></a> Ant</h3><ul><li><a href="ant.md">Ant 简易教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构建工具&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#构建工具&quot;&gt;&lt;/a&gt; 构建工具&lt;/h1&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/javatool/README/</id>
    <published>2019-03-06T08:38:12.706Z</published>
    <updated>2019-03-22T04:08:13.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-工具"><a class="markdownIt-Anchor" href="#java-工具"></a> Java 工具</h1><blockquote><p>本部分内容主要是 Java 开发领域使用的一些 Java 工具，如构建工具、IDE、服务器、日志中心等等。</p></blockquote><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="build/README.md">构建工具</a><ul><li><a href="build/maven/maven-quickstart.md">Maven 快速指南</a></li><li><a href="build/maven/maven-pom.md">Maven 之 pom.xml 详解</a></li><li><a href="build/maven/maven-settings.md">Maven 之 settings.xml 详解</a></li><li><a href="build/maven/maven-action.md">Maven 常见问题和最佳实践</a></li><li><a href="build/maven/maven-deploy.md">发布项目到 Maven 中央仓库</a></li><li><a href="build/maven/nexus.md">部署并使用 Nexus 作为 Maven 私服</a></li><li><a href="build/ant.md">Ant 简易教程</a></li></ul></li><li><a href="elastic/README.md">Elastic</a><ul><li><a href="elastic/elastic-quickstart.md">Elastic 技术栈之快速指南</a></li><li><a href="elastic/elastic-logstash.md">Elastic 技术栈之 Logstash 基础</a></li></ul></li><li><a href="ide/README.md">Java IDE</a><ul><li><a href="ide/intellij.md">Intellij IDEA 使用小结</a></li><li><a href="ide/eclipse.md">Eclipse 使用小结</a></li></ul></li><li><a href="server/README.md">Java 服务器</a><ul><li><a href="server/jetty.md">Jetty 使用小结</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-工具&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-工具&quot;&gt;&lt;/a&gt; Java 工具&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本部分内容主要是 Java 开发领域使用的一些 Java 工具，如构建工具、IDE、服务
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javastack/appendix/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javastack/appendix/README/</id>
    <published>2019-03-06T08:38:12.622Z</published>
    <updated>2019-03-22T04:08:13.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="java-资源"><a class="markdownIt-Anchor" href="#java-资源"></a> <a href="resources.html">Java 资源</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;附录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#附录&quot;&gt;&lt;/a&gt; 附录&lt;/h1&gt;
&lt;h2 id=&quot;java-资源&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-资源&quot;&gt;&lt;/a&gt; &lt;a href=
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/programming/java/javacore/concurrent/README/"/>
    <id>https://dunwu.github.io/2019/03/06/programming/java/javacore/concurrent/README/</id>
    <published>2019-03-06T08:38:12.520Z</published>
    <updated>2019-03-22T04:08:12.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-并发"><a class="markdownIt-Anchor" href="#java-并发"></a> Java 并发</h1><h2 id="内容目录"><a class="markdownIt-Anchor" href="#内容目录"></a> 内容目录</h2><ul><li><a href="Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86.md">Java 并发面试题集</a></li><li><a href="%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B.md">第一章 并发简介</a></li><li><a href="%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.md">第二章 线程基础</a></li><li><a href="%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.md">第三章 并发机制的底层实现</a></li><li><a href="%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.md">第四章 内存模型</a></li><li><a href="%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.md">第五章 同步容器和并发容器</a></li><li><a href="%E9%94%81.md">第六章 锁</a></li><li><a href="%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB.md">第七章 原子变量类</a></li><li><a href="%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB.md">第八章 并发工具类</a></li><li><a href="%E7%BA%BF%E7%A8%8B%E6%B1%A0.md">第九章 线程池</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-并发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-并发&quot;&gt;&lt;/a&gt; Java 并发&lt;/h1&gt;
&lt;h2 id=&quot;内容目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容目录&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/os/README/"/>
    <id>https://dunwu.github.io/2019/03/06/os/README/</id>
    <published>2019-03-06T08:38:11.904Z</published>
    <updated>2019-03-22T04:08:12.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1><blockquote><p>🎯 所有配套源码整理归档在 <a href="https://github.com/dunwu/os-tutorial" target="_blank" rel="noopener"><strong>os-tutorial</strong></a> 项目中。</p></blockquote><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><ul><li><a href="linux">Linux</a></li><li><a href="windows">Windows</a></li><li><a href="docker">Docker</a></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统&quot;&gt;&lt;/a&gt; 操作系统&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;🎯 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/dunwu/os-t
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
</feed>
