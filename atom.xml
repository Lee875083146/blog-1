<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>静默虚空的博客</title>
  
  <subtitle>大道至简，知易行难</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://dunwu.github.io/"/>
  <updated>2019-04-24T11:49:25.259Z</updated>
  <id>https://dunwu.github.io/</id>
  
  <author>
    <name>Zhang Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式技术面试题</title>
    <link href="https://dunwu.github.io/2019/04/25/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://dunwu.github.io/2019/04/25/design/architecture/分布式技术面试题/</id>
    <published>2019-04-25T05:19:09.938Z</published>
    <updated>2019-04-24T11:49:25.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式技术面试题"><a class="markdownIt-Anchor" href="#分布式技术面试题"></a> 分布式技术面试题</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98">1. 分布式缓存</a><ul><li><a href="#11-redis-%E6%9C%89%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF">1.1. Redis 有什么数据类型？分别用于什么场景？</a></li><li><a href="#12-redis-%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.2. Redis 的主从复制是如何实现的？</a></li><li><a href="#13-redis-%E7%9A%84-key-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84">1.3. Redis 的 key 是如何寻址的？</a></li><li><a href="#14-redis-%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84">1.4. Redis 的集群模式是如何实现的？</a></li><li><a href="#15-redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81zookeeper-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%AF%94%E8%BE%83%E4%BA%8C%E8%80%85%E4%BC%98%E5%8A%A3">1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</a></li><li><a href="#16-redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</a></li><li><a href="#17-redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">1.7. Redis 过期策略有哪些？</a></li><li><a href="#18-redis-%E5%92%8C-memcached-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">1.8. Redis 和 Memcached 有什么区别？</a></li><li><a href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84-redis-%E6%80%A7%E8%83%BD%E5%8F%8D%E8%80%8C%E4%BC%98%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84-memcached">1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</a></li></ul></li><li><a href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq">2. 分布式消息队列（MQ）</a><ul><li><a href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-mq">2.1. 为什么使用 MQ？</a></li><li><a href="#22-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-mq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8">2.2. 如何保证 MQ 的高可用？</a></li><li><a href="#23-mq-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98">2.3. MQ 有哪些常见问题？如何解决这些问题？</a></li><li><a href="#24-kafka-activemq-rabbitmq-rocketmq-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9">2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</a></li></ul></li><li><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1rpc">3. 分布式服务（RPC）</a><ul><li><a href="#31-dubbo-%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">3.1. Dubbo 的实现过程？</a></li><li><a href="#32-dubbo-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">3.2. Dubbo 负载均衡策略有哪些？</a></li><li><a href="#33-dubbo-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5-">3.3. Dubbo 集群容错策略 ？</a></li><li><a href="#34-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%AD%96%E7%95%A5">3.4. 动态代理策略？</a></li><li><a href="#35-dubbo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AEhessianhessian-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</a></li><li><a href="#36-protoco-buffer-%E6%98%AF%E4%BB%80%E4%B9%88">3.6. Protoco Buffer 是什么？</a></li><li><a href="#37-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%8C%82%E4%BA%86%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E9%80%9A%E4%BF%A1%E5%90%97">3.7. 注册中心挂了可以继续通信吗？</a></li><li><a href="#38-zookeeper-%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88zookeeper-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</a></li><li><a href="#39-netty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8niobioaio-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</a></li><li><a href="#310-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86%E6%8B%86%E5%88%86%E4%B8%8D%E7%94%A8-dubbo-%E5%8F%AF%E4%BB%A5%E5%90%97">3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</a></li><li><a href="#311-dubbo-%E5%92%8C-thrift-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3.11. Dubbo 和 Thrift 有什么区别？</a></li></ul></li></ul><!-- /TOC --><h2 id="1-分布式缓存"><a class="markdownIt-Anchor" href="#1-分布式缓存"></a> 1. 分布式缓存</h2><h3 id="11-redis-有什么数据类型分别用于什么场景"><a class="markdownIt-Anchor" href="#11-redis-有什么数据类型分别用于什么场景"></a> 1.1. Redis 有什么数据类型？分别用于什么场景？</h3><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th></tr></thead><tbody><tr><td>STRING</td><td>字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td>LIST</td><td>列表</td><td>从两端压入或者弹出元素<br> 读取单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td>SET</td><td>无序集合</td><td>添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td>HASH</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td>ZSET</td><td>有序集合</td><td>添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h3 id="12-redis-的主从复制是如何实现的"><a class="markdownIt-Anchor" href="#12-redis-的主从复制是如何实现的"></a> 1.2. Redis 的主从复制是如何实现的？</h3><ol><li>从服务器连接主服务器，发送 SYNC 命令；</li><li>主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；</li><li>主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ol><h3 id="13-redis-的-key-是如何寻址的"><a class="markdownIt-Anchor" href="#13-redis-的-key-是如何寻址的"></a> 1.3. Redis 的 key 是如何寻址的？</h3><h4 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h4><p>（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：</p><ul><li><a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 存储着 redis 数据库以整数表示的号码。</li><li>redisDb.dict 存储着该库所有的键值对数据。</li><li>redisDb.expires 保存着每一个键的过期时间。</li></ul><p>（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 <a href="http://redisDb.id" target="_blank" rel="noopener">redisDb.id</a> 即可。</p><p>（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。</p><p>（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。</p><h4 id="寻址-key-的步骤"><a class="markdownIt-Anchor" href="#寻址-key-的步骤"></a> 寻址 key 的步骤</h4><ol><li>当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为 true 直接返回 NULL。</li><li>判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</li><li>计算哈希表，根据当前字典与 key 进行哈希值的计算。</li><li>根据哈希值与当前字典计算哈希表的索引值。</li><li>根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。</li><li>当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。</li></ol><h3 id="14-redis-的集群模式是如何实现的"><a class="markdownIt-Anchor" href="#14-redis-的集群模式是如何实现的"></a> 1.4. Redis 的集群模式是如何实现的？</h3><p>Redis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。</p><p>Redis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p><h4 id="redis-cluster-节点分配"><a class="markdownIt-Anchor" href="#redis-cluster-节点分配"></a> Redis Cluster 节点分配</h4><p>Redis Cluster 特点：</p><ol><li>所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</li><li>redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node、slot、value。</li><li>Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。</li></ol><h4 id="redis-cluster-主从模式"><a class="markdownIt-Anchor" href="#redis-cluster-主从模式"></a> Redis Cluster 主从模式</h4><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式。</p><p>一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。</p><h4 id="redis-sentinel"><a class="markdownIt-Anchor" href="#redis-sentinel"></a> Redis Sentinel</h4><p>Redis Sentinel 用于管理多个 Redis 服务器，它有三个功能：</p><ul><li><strong>监控（Monitoring）</strong> - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong> - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong> - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis 集群中应该有奇数个节点，所以至少有三个节点。</p><p>哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。</p><p>假设集群仅仅部署 2 个节点</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。</p><h3 id="15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"><a class="markdownIt-Anchor" href="#15-redis-如何实现分布式锁zookeeper-如何实现分布式锁比较二者优劣"></a> 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？</h3><p>分布式锁的三种实现：</p><ul><li>基于数据库实现分布式锁；</li><li>基于缓存（Redis 等）实现分布式锁；</li><li>基于 Zookeeper 实现分布式锁；</li></ul><h4 id="数据库实现"><a class="markdownIt-Anchor" href="#数据库实现"></a> 数据库实现</h4><h4 id="redis-实现"><a class="markdownIt-Anchor" href="#redis-实现"></a> Redis 实现</h4><ol><li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。</li><li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li><li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li></ol><h4 id="zookeeper-实现"><a class="markdownIt-Anchor" href="#zookeeper-实现"></a> ZooKeeper 实现</h4><ol><li>创建一个目录 mylock；</li><li>线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；</li><li>获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；</li><li>线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；</li><li>线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</li></ol><h4 id="实现对比"><a class="markdownIt-Anchor" href="#实现对比"></a> 实现对比</h4><p>ZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。<br>但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。</p><h3 id="16-redis-的持久化方式有什么优缺点持久化实现原理"><a class="markdownIt-Anchor" href="#16-redis-的持久化方式有什么优缺点持久化实现原理"></a> 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？</h3><h4 id="rdb-快照snapshot"><a class="markdownIt-Anchor" href="#rdb-快照snapshot"></a> RDB 快照（snapshot）</h4><p>将存在于某一时刻的所有数据都写入到硬盘中。</p><h5 id="快照的原理"><a class="markdownIt-Anchor" href="#快照的原理"></a> 快照的原理</h5><p>在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。</p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</p><ul><li>Redis 创建一个子进程。</li><li>子进程将数据集写入到一个临时快照文件中。</li><li>当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。</li></ul><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h5 id="快照的优点"><a class="markdownIt-Anchor" href="#快照的优点"></a> 快照的优点</h5><ul><li>它保存了某个时间点的数据集，非常适用于数据集的备份。</li><li>很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li><li>快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。</li><li>与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。</li></ul><h5 id="快照的缺点"><a class="markdownIt-Anchor" href="#快照的缺点"></a> 快照的缺点</h5><ul><li>如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。</li><li>快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。</li></ul><h4 id="aof"><a class="markdownIt-Anchor" href="#aof"></a> AOF</h4><p>AOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p><h4 id="aof-的原理"><a class="markdownIt-Anchor" href="#aof-的原理"></a> AOF 的原理</h4><ul><li>Redis 创建一个子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ul><h4 id="aof-的优点"><a class="markdownIt-Anchor" href="#aof-的优点"></a> AOF 的优点</h4><ul><li>使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。</li><li>AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。</li></ul><h4 id="aof-的缺点"><a class="markdownIt-Anchor" href="#aof-的缺点"></a> AOF 的缺点</h4><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。</li></ul><h3 id="17-redis-过期策略有哪些"><a class="markdownIt-Anchor" href="#17-redis-过期策略有哪些"></a> 1.7. Redis 过期策略有哪些？</h3><ul><li><strong>noeviction</strong> - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。</li><li><strong>allkeys-lru</strong> - 在主键空间中，优先移除最近未使用的 key。</li><li><strong>allkeys-random</strong> - 在主键空间中，随机移除某个 key。</li><li><strong>volatile-lru</strong> - 在设置了过期时间的键空间中，优先移除最近未使用的 key。</li><li><strong>volatile-random</strong> - 在设置了过期时间的键空间中，随机移除某个 key。</li><li><strong>volatile-ttl</strong> - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。</li></ul><h3 id="18-redis-和-memcached-有什么区别"><a class="markdownIt-Anchor" href="#18-redis-和-memcached-有什么区别"></a> 1.8. Redis 和 Memcached 有什么区别？</h3><p>两者都是非关系型内存键值数据库。有以下主要不同：</p><p><strong>数据类型</strong></p><ul><li>Memcached 仅支持字符串类型；</li><li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li></ul><p><strong>数据持久化</strong></p><ul><li>Memcached 不支持持久化；</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li></ul><p><strong>分布式</strong></p><ul><li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul><p><strong>内存管理机制</strong></p><ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li></ul><h3 id="19-为什么单线程的-redis-性能反而优于多线程的-memcached"><a class="markdownIt-Anchor" href="#19-为什么单线程的-redis-性能反而优于多线程的-memcached"></a> 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？</h3><p>Redis 快速的原因：</p><ol><li>绝大部分请求是纯粹的内存操作（非常快速）</li><li>采用单线程,避免了不必要的上下文切换和竞争条件</li><li>非阻塞 IO</li></ol><p>内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。</p><h2 id="2-分布式消息队列mq"><a class="markdownIt-Anchor" href="#2-分布式消息队列mq"></a> 2. 分布式消息队列（MQ）</h2><h3 id="21-为什么使用-mq"><a class="markdownIt-Anchor" href="#21-为什么使用-mq"></a> 2.1. 为什么使用 MQ？</h3><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h3 id="22-如何保证-mq-的高可用"><a class="markdownIt-Anchor" href="#22-如何保证-mq-的高可用"></a> 2.2. 如何保证 MQ 的高可用？</h3><h4 id="数据复制"><a class="markdownIt-Anchor" href="#数据复制"></a> 数据复制</h4><ol><li>将所有 Broker 和待分配的 Partition 排序</li><li>将第 i 个 Partition 分配到第（i mod n）个 Broker 上</li><li>将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上</li></ol><h4 id="选举主服务器"><a class="markdownIt-Anchor" href="#选举主服务器"></a> 选举主服务器</h4><h3 id="23-mq-有哪些常见问题如何解决这些问题"><a class="markdownIt-Anchor" href="#23-mq-有哪些常见问题如何解决这些问题"></a> 2.3. MQ 有哪些常见问题？如何解决这些问题？</h3><p>MQ 的常见问题有：</p><ol><li>消息的顺序问题</li><li>消息的重复问题</li></ol><h4 id="消息的顺序问题"><a class="markdownIt-Anchor" href="#消息的顺序问题"></a> 消息的顺序问题</h4><p>消息有序指的是可以按照消息的发送顺序来消费。</p><p>假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-23145c8b554a0f2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><p>解决方案：</p><p>（1）保证生产者 - MQServer - 消费者是一对一对一的关系</p><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-034106d7e04c062d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><p>缺陷：</p><ul><li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li><li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li></ul><p>（2）通过合理的设计或者将问题分解来规避。</p><ul><li>不关注乱序的应用实际大量存在</li><li>队列无序并不意味着消息无序</li></ul><p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。</p><h4 id="消息的重复问题"><a class="markdownIt-Anchor" href="#消息的重复问题"></a> 消息的重复问题</h4><p>造成消息重复的根本原因是：网络不可达。</p><p>所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><p>消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。<br>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。</p><h3 id="24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"><a class="markdownIt-Anchor" href="#24-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点"></a> 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？</h3><div align="center"><img src="http://upload-images.jianshu.io/upload_images/3101171-c26f4a3048c38af4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></div><h2 id="3-分布式服务rpc"><a class="markdownIt-Anchor" href="#3-分布式服务rpc"></a> 3. 分布式服务（RPC）</h2><h3 id="31-dubbo-的实现过程"><a class="markdownIt-Anchor" href="#31-dubbo-的实现过程"></a> 3.1. Dubbo 的实现过程？</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo基本架构.png" width="500"></div><p>节点角色：</p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>调用关系：</p><ol><li>务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h3 id="32-dubbo-负载均衡策略有哪些"><a class="markdownIt-Anchor" href="#32-dubbo-负载均衡策略有哪些"></a> 3.2. Dubbo 负载均衡策略有哪些？</h3><h5 id="random"><a class="markdownIt-Anchor" href="#random"></a> Random</h5><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><h5 id="roundrobin"><a class="markdownIt-Anchor" href="#roundrobin"></a> RoundRobin</h5><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul><h5 id="leastactive"><a class="markdownIt-Anchor" href="#leastactive"></a> LeastActive</h5><ul><li>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</li><li>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</li></ul><h5 id="consistenthash"><a class="markdownIt-Anchor" href="#consistenthash"></a> ConsistentHash</h5><ul><li>一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li><li>算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></li><li>缺省只对第一个参数 Hash，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</code></li><li>缺省用 160 份虚拟节点，如果要修改，请配置 <code>&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</code></li></ul><h3 id="33-dubbo-集群容错策略"><a class="markdownIt-Anchor" href="#33-dubbo-集群容错策略"></a> 3.3. Dubbo 集群容错策略 ？</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/dubbo/dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99.jpg"></div><ul><li><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</li><li><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</li><li><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><h3 id="34-动态代理策略"><a class="markdownIt-Anchor" href="#34-动态代理策略"></a> 3.4. 动态代理策略？</h3><p>Dubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：</p><div align="center"><img src="https://oscimg.oschina.net/oscnet/bef19cd5a31b5ae13aff35a8cb4898faaf0.jpg"></div><p>消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是<strong>ProxyFactory</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI(“javassist”)，默认为 javassist 的实现。</p><h3 id="35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"><a class="markdownIt-Anchor" href="#35-dubbo-支持哪些序列化协议hessianhessian-的数据结构"></a> 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？</h3><ol><li>dubbo 序列化，阿里尚不成熟的 java 序列化实现。</li><li>hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。</li><li>json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。</li><li>java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。</li><li>Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。</li></ol><p>Hessian 序列化与 Java 默认的序列化区别？</p><p>Hessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。</p><ol><li>Hessian 支持跨语言串行</li><li>比 java 序列化具有更好的性能和易用性</li><li>支持的语言比较多</li></ol><h3 id="36-protoco-buffer-是什么"><a class="markdownIt-Anchor" href="#36-protoco-buffer-是什么"></a> 3.6. Protoco Buffer 是什么？</h3><p>Protocol Buffer 是 Google 出品的一种轻量 &amp; 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！</p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</li><li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><ol><li>采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li><li>采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</li></ol><h3 id="37-注册中心挂了可以继续通信吗"><a class="markdownIt-Anchor" href="#37-注册中心挂了可以继续通信吗"></a> 3.7. 注册中心挂了可以继续通信吗？</h3><p>可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。</p><h3 id="38-zookeeper-原理是什么zookeeper-有什么用"><a class="markdownIt-Anchor" href="#38-zookeeper-原理是什么zookeeper-有什么用"></a> 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？</h3><p>ZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/JavaWeb/master/images/distributed/rpc/zookeeper/zookeeper-service.png"></div><ol><li>每个 Server 在内存中存储了一份数据；</li><li>Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；</li><li>Leader 负责处理数据更新等操作（Zab 协议）；</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。</li></ol><h3 id="39-netty-有什么用niobioaio-有什么用有什么区别"><a class="markdownIt-Anchor" href="#39-netty-有什么用niobioaio-有什么用有什么区别"></a> 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？</h3><p>Netty 是一个“网络通讯框架”。</p><p>Netty 进行事件处理的流程。<code>Channel</code>是连接的通道，是 ChannelEvent 的产生者，而<code>ChannelPipeline</code>可以理解为 ChannelHandler 的集合。</p><div align="center"><img src="https://camo.githubusercontent.com/5f7331d15c79fba29474c5be6e9e86db465637c3/687474703a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f73706163652f323031332f303932312f3137343033325f313872625f3139303539312e706e67"></div><blockquote><p>参考：<a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md" target="_blank" rel="noopener">https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md</a></p></blockquote><p>IO 的方式通常分为几种：</p><ul><li>同步阻塞的 BIO</li><li>同步非阻塞的 NIO</li><li>异步非阻塞的 AIO</li></ul><p>在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。</p><p>NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。</p><blockquote><p>参考：<a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">https://blog.csdn.net/skiof007/article/details/52873421</a></p></blockquote><h3 id="310-为什么要进行系统拆分拆分不用-dubbo-可以吗"><a class="markdownIt-Anchor" href="#310-为什么要进行系统拆分拆分不用-dubbo-可以吗"></a> 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？</h3><p>系统拆分从资源角度分为：应用拆分和数据库拆分。</p><p>从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。</p><div align="center"><img src="http://misc.linkedkeeper.com/misc/img/blog/201804/linkedkeeper0_9c2ed2ed-6156-40f7-ad08-20af067047ca.jpg"></div><p>是否使用服务依据实际业务场景来决定。</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h3 id="311-dubbo-和-thrift-有什么区别"><a class="markdownIt-Anchor" href="#311-dubbo-和-thrift-有什么区别"></a> 3.11. Dubbo 和 Thrift 有什么区别？</h3><ul><li>Thrift 是跨语言的 RPC 框架。</li><li>Dubbo 支持服务治理，而 Thrift 不支持。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式技术面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式技术面试题&quot;&gt;&lt;/a&gt; 分布式技术面试题&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%
      
    
    </summary>
    
      <category term="design" scheme="https://dunwu.github.io/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/tags/architecture/"/>
    
      <category term="distributed" scheme="https://dunwu.github.io/tags/distributed/"/>
    
      <category term="interview" scheme="https://dunwu.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>React 快速入门</title>
    <link href="https://dunwu.github.io/2019/04/25/frontend/mvc/react/"/>
    <id>https://dunwu.github.io/2019/04/25/frontend/mvc/react/</id>
    <published>2019-04-25T03:37:50.012Z</published>
    <updated>2019-04-24T11:49:27.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-快速入门"><a class="markdownIt-Anchor" href="#react-快速入门"></a> React 快速入门</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E5%AE%89%E8%A3%85">安装</a></li><li><a href="#introducing-jsx">Introducing JSX</a><ul><li><a href="#jsx-%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F">JSX 中嵌入表达式</a></li><li><a href="#jsx-%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F">JSX 也是一个表达式</a></li><li><a href="#%E7%94%A8-jsx-%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E5%80%BC">用 JSX 指定属性值</a></li><li><a href="#%E7%94%A8-jsx-%E6%8C%87%E5%AE%9A%E5%AD%90%E5%85%83%E7%B4%A0">用 JSX 指定子元素</a></li><li><a href="#jsx-%E9%98%B2%E6%AD%A2%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">JSX 防止注入攻击</a></li><li><a href="#jsx-%E8%A1%A8%E7%A4%BA%E5%AF%B9%E8%B1%A1">JSX 表示对象</a></li></ul></li><li><a href="#%E6%B8%B2%E6%9F%93%E5%85%83%E7%B4%A0">渲染元素</a><ul><li><a href="#%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%B0-dom">渲染一个元素到 DOM</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E5%B7%B2%E6%B8%B2%E6%9F%93%E7%9A%84%E5%85%83%E7%B4%A0">更新已渲染的元素</a></li><li><a href="#react-%E5%8F%AA%E6%9B%B4%E6%96%B0%E5%BF%85%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0%E7%9A%84%E9%83%A8%E5%88%86">React 只更新必需要更新的部分</a></li></ul></li><li><a href="#%E7%BB%84%E4%BB%B6components-%E5%92%8C-%E5%B1%9E%E6%80%A7props">组件(Components) 和 属性(Props)</a><ul><li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%BB%84%E4%BB%B6">函数式组件和类组件</a></li><li><a href="#%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6">渲染一个组件</a></li><li><a href="#%E6%9E%84%E6%88%90%E7%BB%84%E4%BB%B6">构成组件</a></li><li><a href="#%E6%8F%90%E5%8F%96%E7%BB%84%E4%BB%B6">提取组件</a></li><li><a href="#props-%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%9A%84">Props 是只读的</a></li></ul></li><li><a href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%B1%BB%E7%BB%84%E4%BB%B6">把函数式组件转化为类组件</a></li><li><a href="#%E5%9C%A8%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%8A%B6%E6%80%81state">在类组件中添加本地状态(state)</a></li><li><a href="#%E5%9C%A8%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95">在类中添加生命周期方法</a></li><li><a href="#%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-state%E7%8A%B6%E6%80%81">正确地使用 State(状态)</a><ul><li><a href="#%E4%B8%8D%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-state%E7%8A%B6%E6%80%81">不要直接修改 state(状态)</a></li><li><a href="#state%E7%8A%B6%E6%80%81-%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84">state(状态) 更新可能是异步的</a></li><li><a href="#state%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E4%BC%9A%E8%A2%AB%E5%90%88%E5%B9%B6">state(状态)更新会被合并</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%90%91%E4%B8%8B%E6%B5%81%E5%8A%A8">数据向下流动</a><ul><li><a href="#%E5%85%83%E7%B4%A0%E5%8F%98%E9%87%8F">元素变量</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91--%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%86%85%E8%81%94-if-%E7%94%A8%E6%B3%95">使用逻辑 &amp;&amp; 操作符的内联 if 用法</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%86%85%E8%81%94-if-else">使用条件操作符的内联 If-Else</a></li><li><a href="#%E9%98%B2%E6%AD%A2%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">防止组件渲染</a></li><li><a href="#%E5%A4%9A%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93">多组件渲染</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6">基本列表组件</a></li></ul></li><li><a href="#%E9%94%AEkeys">键(Keys)</a><ul><li><a href="#%E4%BD%BF%E7%94%A8-keys-%E6%8F%90%E5%8F%96%E7%BB%84%E4%BB%B6">使用 keys 提取组件</a></li><li><a href="#keys-%E5%9C%A8%E5%90%8C%E8%BE%88%E5%85%83%E7%B4%A0%E4%B8%AD%E5%BF%85%E9%A1%BB%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84">keys 在同辈元素中必须是唯一的</a></li><li><a href="#%E5%9C%A8-jsx-%E4%B8%AD%E5%B5%8C%E5%85%A5-map">在 JSX 中嵌入 map()</a></li></ul></li><li><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-components">受控组件(Controlled Components)</a></li><li><a href="#textare-%E6%A0%87%E7%AD%BE">textare 标签</a></li><li><a href="#select-%E6%A0%87%E7%AD%BE">select 标签</a></li><li><a href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E8%BE%93%E5%85%A5%E5%85%83%E7%B4%A0">处理多个输入元素</a></li><li><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88">受控组件的替代方案</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BE%93%E5%85%A5">添加第二个输入</a></li><li><a href="#%E7%BC%96%E5%86%99%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">编写转换函数</a></li><li><a href="#%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87lifting-state-up">状态提升(Lifting State Up)</a></li><li><a href="#%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93">经验总结</a></li><li><a href="#%E5%8C%85%E5%90%AB">包含</a></li><li><a href="#%E7%89%B9%E4%BE%8B">特例</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85">如何看待？</a></li></ul><!-- /TOC --><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><ol><li>直接下载使用</li></ol><p>React 可以直接下载使用，下载包中也提供了很多学习的实例。</p><p>你可以在官网  <a href="http://facebook.github.io/react/" target="_blank" rel="noopener">http://facebook.github.io/react/</a>  下载最新版。</p><ol start="2"><li>通过 npm 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -S react react-dom</span><br></pre></td></tr></table></figure><ol start="3"><li>通过 yarn 使用 React</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ yarn add react react-dom</span><br></pre></td></tr></table></figure><ol start="4"><li><p>使用各种快速构建工具</p><p>目前最流行的构建工具应该是 create-react-app，它使得用户可以通过命令就能快速构建 React 开发环境。</p><p>create-react-app 自动创建的项目是基于 Webpack + ES6 。</p></li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br><span class="line">$ create-react-app my-app</span><br><span class="line">$ <span class="built_in">cd</span> my-app/</span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><h2 id="introducing-jsx"><a class="markdownIt-Anchor" href="#introducing-jsx"></a> Introducing JSX</h2><p>考虑一下这个变量的声明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>这种有趣的标签语法既不是字符串也不是 HTML。</p><p>这就是 JSX ，他是 JavaScrip 的一种扩展语法。我们推荐在 React 中使用这种语法来描述 UI 信息。JSX 可能会让你想起某种模板语言，但是它具有 JavaScrip 的全部能力。</p><p>JSX 可以生成 React “元素”。我们将在<a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">下一章</a>探索如何把它渲染到 DOM 上。下面你可以找到 JSX 的基础知识，以帮助您开始使用。</p><h3 id="jsx-中嵌入表达式"><a class="markdownIt-Anchor" href="#jsx-中嵌入表达式"></a> JSX 中嵌入表达式</h3><p>你可以用 花括号 把任意的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript 表达式</a>  嵌入到 JSX 中。</p><p>例如，<code>2 + 2</code>， <code>user.firstName</code>， 和  <code>formatName(user)</code>，这些都是可用的表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/PGEjdG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>为便于阅读，我们将 JSX 分割成多行。我们推荐使用括号将 JSX 包裹起来，虽然这不是必须的，但这样做可以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">分号自动插入</a>的陷阱。</p><h3 id="jsx-也是一个表达式"><a class="markdownIt-Anchor" href="#jsx-也是一个表达式"></a> JSX 也是一个表达式</h3><p>编译之后，JSX 表达式就变成了常规的 JavaScript 对象。</p><p>这意味着你可以在  <code>if</code>  语句或者是  <code>for</code>  循环中使用 JSX，用它给变量赋值，当做参数接收，或者作为函数的返回值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-jsx-指定属性值"><a class="markdownIt-Anchor" href="#用-jsx-指定属性值"></a> 用 JSX 指定属性值</h3><p>您可以使用双引号来指定字符串字面量作为属性值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>您也可以用花括号嵌入一个 JavaScript 表达式作为属性值:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>在属性中嵌入 JavaScript 表达式时，不要使用引号来包裹大括号。否则，JSX 将该属性视为字符串字面量而不是表达式。对于字符串值你应该使用引号，对于表达式你应该使用大括号，但两者不能同时用于同一属性。</p><h3 id="用-jsx-指定子元素"><a class="markdownIt-Anchor" href="#用-jsx-指定子元素"></a> 用 JSX 指定子元素</h3><p>如果是空标签，您应该像 XML 一样，使用  <code>/&gt;</code>立即闭合它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure><p>JSX 标签可能包含子元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p><strong>警告：</strong></p><p>比起 HTML ， JSX 更接近于 JavaScript ， 所以 React DOM 使用驼峰(<code>camelCase</code>)属性命名约定, 而不是 HTML 属性名称。</p><p>例如，<code>class</code>  在 JSX 中变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，<code>tabindex</code>  变为  <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p></blockquote><h3 id="jsx-防止注入攻击"><a class="markdownIt-Anchor" href="#jsx-防止注入攻击"></a> JSX 防止注入攻击</h3><p>在 JSX 中嵌入用户输入是安全的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>默认情况下， 在渲染之前, React DOM 会格式化(<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a>) JSX 中的所有值. 从而保证用户无法注入任何应用之外的代码. 在被渲染之前，所有的数据都被转义成为了字符串处理。 以避免  <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站脚本)</a>  攻击。</p><h3 id="jsx-表示对象"><a class="markdownIt-Anchor" href="#jsx-表示对象"></a> JSX 表示对象</h3><p>Babel 将 JSX 编译成  <code>React.createElement()</code>  调用。</p><p>下面的两个例子是是完全相同的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const element</span> = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;className: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>React.createElement()</code>  会执行一些检查来帮助你编写没有 bug 的代码，但基本上它会创建一个如下所示的对象：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 这是简化的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些对象被称作“React 元素”。你可以把他们想象成为你想在屏幕上显示内容的一种描述。React 会读取这些对象，用他们来构建 DOM，并且保持它们的不断更新。</p><p>我们将在下一节中来探索如何将 React 元素渲染到 DOM 上。</p><blockquote><p><strong>提示:</strong></p><p>我们建议你去搜一下你用的编辑器的 “Babel” 语法方案, 以便 ES6 和 JSX 代码都能够被正确高亮的显示。</p></blockquote><h2 id="渲染元素"><a class="markdownIt-Anchor" href="#渲染元素"></a> 渲染元素</h2><p>元素(Elements)是 React 应用中最小的建造部件（或者说构建块，building blocks）。</p><p>一个元素用于描述你在将在屏幕上看到的内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>不同于浏览器的 DOM 元素， React 元素是普通的对象，非常容易创建。React DOM 会负责更新 DOM ，以匹配 React 元素（愚人码头注：DOM 元素与 React 元素保持一致）。</p><blockquote><p><strong>注意：</strong></p><p>有人可能会将元素与更广为人知的 “组件(Components)” 概念相混淆。我们将在<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">下一节</a>介绍组件。元素是构成组件的&quot;材料&quot;， 所以我们建议你看完本节再进入下一节。</p></blockquote><h3 id="渲染一个元素到-dom"><a class="markdownIt-Anchor" href="#渲染一个元素到-dom"></a> 渲染一个元素到 DOM</h3><p>我们假设你的 HTML 文件中的什么地方有这么一个``：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>我们称这个是一个 “根” DOM 节点，因为该节点内的所有内容都由 React DOM 管理。</p><p>单纯用 React 构建的应用程序通常只有一个单独的 根 DOM 节点。但如果你要把 React 整合进现有的 app 中 ，那你可能会有多个相互独立的根 DOM 节点。</p><p>要渲染一个 React 元素到一个 根 DOM 节点，吧它们传递给  <code>ReactDOM.render()</code>  方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrpgNB?editors=1010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>上面代码会在页面上显示 “Hello, world” 。</p><h3 id="更新已渲染的元素"><a class="markdownIt-Anchor" href="#更新已渲染的元素"></a> 更新已渲染的元素</h3><p>React 元素是  <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">不可突变（immutable）</a>  的. 一旦你创建了一个元素, 就不能再修改其子元素或任何属性。一个元素就像电影里的一帧: 它表示在某一特定时间点的 UI 。</p><p>就我们所知, 更新 UI 的唯一方法是创建一个新的元素, 并将其传入<code>ReactDOM.render()</code>方法.</p><p>思考以下时钟例子:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>以上代码每隔 1 秒, 就会通过  <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener"><code>setInterval()</code></a>  回调  <code>ReactDOM.render()</code>  方法来重新渲染元素。</p><blockquote><p><strong>注意：</strong></p><p>实际上，大多数 React 应用只会调用  <code>ReactDOM.render()</code>  一次。在接下来的章节中，我们将学习如何将这些代码封装到<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">有状态的组件中</a>。</p><p>我们建议您不要跳过任何一节，因为每一节之间都是彼此有联系的。</p></blockquote><h3 id="react-只更新必需要更新的部分"><a class="markdownIt-Anchor" href="#react-只更新必需要更新的部分"></a> React 只更新必需要更新的部分</h3><p>React DOM 会将元素及其子元素与之前版本逐一对比, 并只对有必要更新的 DOM 进行更新, 以达到 DOM 所需的状态。</p><p>你可以用浏览器工具对  <a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">上一个例子</a>  进行检查来验证这一点:</p><div align="center"><img src="http://www.css88.com/react/img/docs/granular-dom-updates.gif"></div><p>即使我们我们每隔 1 秒都重建了整个元素, 但实际上 React DOM 只更新了修改过的文本节点.</p><p>在我们的经验中, 关注每个时间点 UI 的表现, 而不是关注随着时间不断更新 UI 的状态, 可以减少很多奇怪的 bug 。</p><h2 id="组件components-和-属性props"><a class="markdownIt-Anchor" href="#组件components-和-属性props"></a> 组件(Components) 和 属性(Props)</h2><p>组件使你可以将 UI 划分为一个一个独立，可复用的小部件，并可以对每个部件进行单独的设计。</p><p>从定义上来说， 组件就像 JavaScript 的函数。组件可以接收任意输入(称为&quot;props&quot;)， 并返回 React 元素，用以描述屏幕显示内容。</p><blockquote><p>愚人码头注：Props ， 即属性(Property)， 在代码中写作 props ， 故可用 props 指代 properties .</p></blockquote><h3 id="函数式组件和类组件"><a class="markdownIt-Anchor" href="#函数式组件和类组件"></a> 函数式组件和类组件</h3><p>最简单的定义组件的方法是写一个 JavaScript 函数:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是一个合法的 React 组件，因为它接收一个  <code>props</code>  参数, 并返回一个 React 元素。 我们把此类组件称为&quot;函数式(Functional)&quot;组件， 因为从字面上看来它就是一个 JavaScript 函数。</p><p>你也可以用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 的 class</a>  来定义一个组件:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两个组件从 React 的角度来看是等效的。</p><p>类组件有一些额外的特性，我们将在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>讨论。在此之前, 我们先用函数式组件，因为它们更加简洁。</p><h3 id="渲染一个组件"><a class="markdownIt-Anchor" href="#渲染一个组件"></a> 渲染一个组件</h3><p>在前面, 我们只遇到代表 DOM 标签的 React 元素：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;<span class="keyword">div</span> /&gt;;</span><br></pre></td></tr></table></figure><p>然而，元素也可以代表用户定义的组件：</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const element</span> = &lt;Welcome name=<span class="string">"Sara"</span> /&gt;;</span><br></pre></td></tr></table></figure><p>当 React 遇到一个代表用户定义组件的元素时，它将 JSX 属性以一个单独对象的形式传递给相应的组件。 我们将其称为 “props” 对象。</p><p>比如, 以下代码在页面上渲染 “Hello, Sara” ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/YGYmEG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们简单扼要重述一下上面这个例子:</p><ol><li>我们调用了  <code>ReactDOM.render()</code>  方法并向其中传入了  ``  元素。</li><li>React 调用  <code>Welcome</code>  组件，并向其中传入了  <code>{name: 'Sara'}</code>  作为 props 对象。</li><li><code>Welcome</code>  组件返回  <code>Hello, Sara</code>。</li><li>React DOM 迅速更新 DOM ，使其显示为  <code>Hello, Sara</code>。</li></ol><blockquote><p><strong>警告：</strong></p><p>组件名称总是以大写字母开始。</p><p>举例来说, <code>代表一个 DOM 标签，而</code>  则代表一个组件，并且需要在作用域中有一个  <code>Welcome</code>  组件。</p></blockquote><h3 id="构成组件"><a class="markdownIt-Anchor" href="#构成组件"></a> 构成组件</h3><p>组件可以在它们的输出中引用其它组件。这使得我们可以使用同样的组件来抽象到任意层级。一个按钮，一个表单，一个对话框，一个屏幕：在 React 应用中，所有这些都通常描述为组件。</p><p>例如，我们可以创建一个  <code>App</code>  组件，并在其内部多次渲染  <code>Welcome</code>：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Welcome(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="xquery">&#123;props<span class="built_in">.name</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> App() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Cahal"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Edite"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQKPr?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>通常，新的 React apps 都有一个单独的顶层  <code>App</code>  组件。然而，如果你在已有的应用中整合 React，你可以需要由下至上地, 从类似于  <code>Button</code>  这样的小组件开始, 逐渐整合到视图层的顶层。</p><blockquote><p><strong>警告：</strong></p><p>组件必须返回一个单独的根元素。这就是为什么我们添加一个  <code>来包含所有</code>  元素的原因。</p></blockquote><h3 id="提取组件"><a class="markdownIt-Anchor" href="#提取组件"></a> 提取组件</h3><p>不要害怕把一个组件分为多个更小的组件。</p><p>举个例子，思考下名  <code>Comment</code>  组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/VKQwEo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它接受  <code>author</code>（一个对象），<code>text</code>（一个字符串）和  <code>date</code>（一个日期）作为 props，并用于在某社交网站中描述一条评论。</p><p>这个组件修改起来很麻烦，因为它是被嵌套的，而且很难复用其中的某个部分。让我们从其中提取一些组件。</p><p>首先，提取头像  <code>Avatar</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Avatar</code>  组件不用关心它在  <code>Comment</code>  中是如何渲染的。这是为什么我们它的 prop 一个更通用的属性名: <code>user</code>, 而不是  <code>author</code>  的原因。</p><p>我们建议从组件本身的角度来命名 props 而不是它被使用的上下文环境。</p><p>我们可以稍微简化一下  <code>Comment</code>  组件:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>接下来，我们提取用户信息  <code>UserInfo</code>  组件， 用于将  <code>Avatar</code>  显示在用户名旁边：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使我们可以进一步简化  <code>Comment</code>  组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/rrJNJY?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>提取组件可能看起来是一个繁琐的工作，但是在大型的 Apps 中可以回报给我们的是大量的可复用组件。一个好的经验准则是如果你 UI 的一部分需要用多次 (<code>Button</code>，<code>Panel</code>，<code>Avatar</code>)，或者本身足够复杂(<code>App</code>，<code>FeedStory</code>，<code>Comment</code>)，最好的做法是使其成为可复用组件。</p><h3 id="props-是只读的"><a class="markdownIt-Anchor" href="#props-是只读的"></a> Props 是只读的</h3><p>无论你用<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">函数或类</a>的方法来声明组件, 它都无法修改其自身 props. 思考下列  <code>sum</code> (求和)函数:</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">a</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种函数称为  <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a> ，因为它们不会试图改变它们的输入，并且对于同样的输入,始终可以得到相同的结果。</p><p>反之， 以下是非纯函数， 因为它改变了自身的输入值：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span><span class="params">(account, amount)</span> </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 React 很灵活，但是它有一条严格的规则：</p><p><strong>所有 React 组件都必须是纯函数，并禁止修改其自身 props 。</strong></p><p>当然， 应用 UI 总是动态的，并且随时有可以改变。 所以在<a href="http://www.css88.com/react/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一节</a>, 我们会介绍一个新的概念<code>state</code>(状态) 。<code>state</code>  允许 React 组件在不违反上述规则的情况下, 根据用户操作, 网络响应, 或者其他随便什么东西, 来动态地改变其输出。</p><h1 id="状态state-和生命周期"><a class="markdownIt-Anchor" href="#状态state-和生命周期"></a> 状态(State) 和生命周期</h1><p>思考<a href="http://www.css88.com/react/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前面章节</a>中提到过的时钟例子.</p><p>目前为止我们只学了一种更新 UI 的方式。</p><p>我们通过调  <code>ReactDOM.render()</code>  方法来更新渲染的输出:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在本节中，我们将学习如何使  <code>Clock</code>  组件变得真正可复用 和 封装的更好。它将设置自己的计时器，并在每秒更新自身。</p><p>我们可以从封装时钟开始：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>然而，它没有满足一个关键的要求：<code>Clock</code>  设置定时器并每秒更新 UI ，事实上应该是  <code>Clock</code>自身实现的一部分。</p><p>理想情况下，我们应该只引用一个  <code>Clock</code> , 然后让它自动计时并更新:</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ReactDOM</span>.</span></span>render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.get<span class="constructor">ElementById('<span class="params">root</span>')</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>要实现这点，我们需要添加  <code>state</code>  到  <code>Clock</code>  组件。</p><p><code>state</code>  和  <code>props</code>  类似，但是它是私有的，并且由组件本身完全控制。</p><p>我们<a href="http://www.css88.com/react/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到过</a>, 用类定义的组件有一些额外的特性。 这个&quot;类专有的特性&quot;， 指的就是局部状态。</p><h2 id="把函数式组件转化为类组件"><a class="markdownIt-Anchor" href="#把函数式组件转化为类组件"></a> 把函数式组件转化为类组件</h2><p>你可以遵从以下 5 步, 把一个类似  <code>Clock</code>  这样的函数式组件转化为类组件：</p><ol><li>创建一个继承自  <code>React.Component</code>  类的  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>  同名类。</li><li>添加一个名为  <code>render()</code>  的空方法。</li><li>把原函数中的所有内容移至  <code>render()</code>  中。</li><li>在  <code>render()</code>  方法中使用  <code>this.props</code>  替代  <code>props</code>。</li><li>删除保留的空函数声明。</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p><code>Clock</code>  现在被定为类组件，而不是函数式组件。</p><p>类允许我们在其中添加本地状态(state)和生命周期钩子。</p><h2 id="在类组件中添加本地状态state"><a class="markdownIt-Anchor" href="#在类组件中添加本地状态state"></a> 在类组件中添加本地状态(state)</h2><p>我们现在通过以下 3 步, 把<code>date</code>从属性(<code>props</code>) 改为 状态(<code>state</code>)：</p><p>We will move the <code>date</code> from props to state in three steps:</p><ol><li>替换  <code>render()</code>  方法中的  <code>this.props.date</code>  为  <code>this.state.date</code>：</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">类构造函数(class constructor)</a>  初始化  <code>this.state</code>:</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们如何将  <code>props</code>  传递给基础构造函数：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.state = &#123;date: new Date()&#125;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件应始终使用  <code>props</code>  调用基础构造函数。</p><ol start="3"><li>移除  ``  元素中的  <code>date</code>  属性：</li></ol><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ReactDOM</span>.</span></span>render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.get<span class="constructor">ElementById('<span class="params">root</span>')</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们稍后再把 计时器代码 添加到组件内部。</p><p>现有的结果是这样:</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Clock</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>接下来，我们将使  <code>Clock</code>  设置自己的计时器，并每秒更新一次。</p><h2 id="在类中添加生命周期方法"><a class="markdownIt-Anchor" href="#在类中添加生命周期方法"></a> 在类中添加生命周期方法</h2><p>在一个具有许多组件的应用程序中，在组件被销毁时释放所占用的资源是非常重要的。</p><p>当  <code>Clock</code>  第一次渲染到 DOM 时，我们要<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个定时器</a> 。 这在 React 中称为 “挂载(mounting)” 。</p><p>当  <code>Clock</code>  产生的 DOM 被销毁时，我们也想<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除该计时器</a>。 这在 React 中称为 “卸载(unmounting)” 。</p><p>当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;date: <span class="keyword">new</span> <span class="type">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法称为 “生命周期钩子”。</p><p><code>componentDidMount()</code>  钩子在组件输出被渲染到 DOM 之后运行。这是设置时钟的不错的位置：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">    () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们把计时器 ID 直接存在  <code>this</code>  中。</p><p><code>this.props</code>  由 React 本身设定, 而  <code>this.state</code>  具有特殊的含义，但如果需要存储一些不用于视觉输出的内容，则可以手动向类中添加额外的字段。</p><p>如果在  <code>render()</code>  方法中没有被引用, 它不应该出现在 state 中。</p><p>我们在<code>componentWillUnmount()</code>生命周期钩子中取消这个计时器：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">component<span class="constructor">WillUnmount()</span> &#123;</span><br><span class="line">  clear<span class="constructor">Interval(<span class="params">this</span>.<span class="params">timerID</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们将会实现每秒运行的  <code>tick()</code>  方法。</p><p>它将使用  <code>this.setState()</code>  来来周期性地更新组件本地状态：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在这个时钟每秒都会走了。</p><p>我们来快速回顾一下该过程，以及调用方法的顺序：</p><ol><li>当  ``  被传入  <code>ReactDOM.render()</code>  时, React 会调用  <code>Clock</code>组件的构造函数。 因为<code>Clock</code>  要显示的是当前时间，所以它将使用包含当前时间的对象来初始化  <code>this.state</code>。我们稍后会更新此状态。</li><li>然后 React 调用了  <code>Clock</code>  组件的  <code>render()</code>  方法。 React 从该方法返回内容中得到要显示在屏幕上的内容。然后，React 然后更新 DOM 以匹配  <code>Clock</code>  的渲染输出。</li><li>当  <code>Clock</code>  输出被插入到 DOM 中时，React 调用  <code>componentDidMount()</code>  生命周期钩子。在该方法中，<code>Clock</code>  组件请求浏览器设置一个定时器来一次调用  <code>tick()</code>。</li><li>浏览器会每隔一秒调用一次  <code>tick()</code>方法。在该方法中， <code>Clock</code>  组件通过  <code>setState()</code>  方法并传递一个包含当前时间的对象来安排一个 UI 的更新。通过  <code>setState()</code>, React 得知了组件  <code>state</code>(状态)的变化, 随即再次调用  <code>render()</code>  方法，获取了当前应该显示的内容。 这次，<code>render()</code>  方法中的  <code>this.state.date</code>  的值已经发生了改变， 从而，其输出的内容也随之改变。React 于是据此对 DOM 进行更新。</li><li>如果通过其他操作将  <code>Clock</code>  组件从 DOM 中移除了, React 会调用<code>componentWillUnmount()</code>  生命周期钩子, 所以计时器也会被停止。</li></ol><h2 id="正确地使用-state状态"><a class="markdownIt-Anchor" href="#正确地使用-state状态"></a> 正确地使用 State(状态)</h2><p>关于  <code>setState()</code>  有三件事是你应该知道的。</p><h3 id="不要直接修改-state状态"><a class="markdownIt-Anchor" href="#不要直接修改-state状态"></a> 不要直接修改 state(状态)</h3><p>例如，这样将不会重新渲染一个组件：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// 错误</span><br><span class="line">this.<span class="keyword">state</span>.comment = 'Hello';</span><br></pre></td></tr></table></figure><p>用  <code>setState()</code>  代替：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="string">comment:</span> <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure><p>唯一可以分配  <code>this.state</code>  的地方是构造函数。</p><h3 id="state状态-更新可能是异步的"><a class="markdownIt-Anchor" href="#state状态-更新可能是异步的"></a> state(状态) 更新可能是异步的</h3><p>React 为了优化性能，有可能会将多个  <code>setState()</code>  调用合并为一次更新。</p><p>因为  <code>this.props</code>  和  <code>this.state</code>  可能是异步更新的，你不能依赖他们的值计算下一个 state(状态)。</p><p>例如, 以下代码可能导致  <code>counter</code>(计数器)更新失败：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要解决这个问题，应该使用第 2 种  <code>setState()</code>  的格式，它接收一个函数，而不是一个对象。该函数接收前一个状态值作为第 1 个参数， 并将更新后的值作为第 21 个参数:</p><p>要弥补这个问题，使用另一种 setState() 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 正确</span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">(prevState, props)</span> =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>我们在上面使用了一个<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是也可以使用一个常规的函数：</p><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span><span class="params">(prevState, props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="state状态更新会被合并"><a class="markdownIt-Anchor" href="#state状态更新会被合并"></a> state(状态)更新会被合并</h3><p>当你调用  <code>setState()</code>， React 将合并你提供的对象到当前的状态中。</p><p>例如，你的状态可能包含几个独立的变量：</p><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    posts: [],</span></span></span><br><span class="line"><span class="function"><span class="comment">    comments: []</span></span></span><br><span class="line"><span class="function"><span class="comment">  &#125;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过调用独立的  <code>setState()</code>  调用分别更新它们:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">componentDidMount</span>() &#123;</span><br><span class="line">  <span class="selector-tag">fetchPosts</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">      <span class="attribute">posts</span>: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">fetchComments</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">      <span class="attribute">comments</span>: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并是浅合并，所以  <code>this.setState({comments})</code>  不会改变  <code>this.state.posts</code>  的值，但会完全替换<code>this.state.comments</code>  的值。</p><h2 id="数据向下流动"><a class="markdownIt-Anchor" href="#数据向下流动"></a> 数据向下流动</h2><p>无论作为父组件还是子组件，它都无法获悉一个组件是否有状态，同时也不需要关心另一个组件是定义为函数组件还是类组件。</p><p>这就是 state(状态) 经常被称为 本地状态 或 封装状态的原因。 它不能被拥有并设置它的组件 以外的任何组件访问。</p><p>一个组件可以选择将 state(状态) 向下传递，作为其子组件的 props(属性)：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="variable">&lt;h2&gt;</span>It is &#123;this.<span class="keyword">state</span>.date.<span class="keyword">to</span>LocaleTimeString()&#125;.&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>同样适用于用户定义组件:</p><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">&lt;FormattedDate <span class="keyword">date</span>=&#123;<span class="keyword">this</span>.state.<span class="keyword">date</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><code>FormattedDate</code>  组件通过 props(属性) 接收了  <code>date</code>  的值，但它仍然不能获知该值是来自于<code>Clock</code>的 state(状态) ，还是  <code>Clock</code>  的 props(属性)，或者是直接手动创建的：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">FormattedDate</span>(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">&lt;h2&gt;It</span> <span class="keyword">is</span> &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这通常称为一个“从上到下”，或者“单向”的数据流。任何 state(状态) 始终由某个特定组件所有，并且从该 state(状态) 导出的任何数据 或 UI 只能影响树中 “下方” 的组件。</p><p>如果把组件树想像为 props(属性) 的瀑布，所有组件的 state(状态) 就如同一个额外的水源汇入主流，且只能随着主流的方向向下流动。</p><p>要证明所有组件都是完全独立的， 我们可以创建一个  <code>App</code>  组件，并在其中渲染 3 个``:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>每个  <code>Clock</code>  都设置它自己的计时器并独立更新。</p><p>在 React 应用中，一个组件是否是有状态或者无状态的，被认为是组件的一个实现细节，随着时间推移可能发生改变。你可以在有状态的组件中使用无状态组件，反之亦然。</p><p>通过 React 元素处理事件跟在 DOM 元素上处理事件非常相似。但是有一些语法上的区别：</p><ul><li>React 事件使用驼峰命名，而不是全部小写。</li><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li></ul><p>例如，HTML：</p><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure><p>在 React 中略有不同：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个区别是，在 React 中你不能通过返回  <code>false</code>（愚人码头注：即  <code>return false;</code>  语句） 来阻止默认行为。必须明确调用  <code>preventDefault</code> 。例如，对于纯 HTML ，要阻止链接打开一个新页面的默认行为，可以这样写：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 React 中, 应该这么写:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这里， e 是一个合成的事件。 React 根据  <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C 规范</a>  定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。查看  <a href="http://www.css88.com/react/docs/events.html" target="_blank" rel="noopener"><code>SyntheticEvent</code></a>  参考指南了解更多。</p><p>当使用 React 时，你一般不需要调用  <code>addEventListener</code>  在 DOM 元素被创建后添加事件监听器。相反，只要当元素被初始渲染的时候提供一个监听器就可以了。</p><p>当使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 类</a>  定义一个组件时，通常的一个事件处理程序是类上的一个方法。例如，<code>Toggle</code>  组件渲染一个按钮，让用户在 “ON” 和 “OFF” 状态之间切换：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isToggleOn: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个绑定是必要的，使`this`在回调中起作用</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="symbol">'O</span>N' : <span class="symbol">'OF</span>F'&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Toggle</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在 JSX 回调中你必须注意  <code>this</code>  的指向。 在 JavaScript 中，类方法默认没有  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>  的。如果你忘记绑定  <code>this.handleClick</code>  并将其传递给<code>onClick</code>，那么在直接调用该函数时，<code>this</code>  会是<code>undefined</code> 。</p><p>这不是 React 特有的行为；这是  <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">JavaScript 中的函数如何工作</a>的一部分。 一般情况下，如果你引用一个后面没跟  <code>()</code>  的方法，例如  <code>onClick={this.handleClick}</code> ，那你就应该 绑定(bind) 该方法。</p><p>如果调用  <code>bind</code>  令你烦恼，有两种方法可以解决这个问题。 如果您使用实验性的  <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">属性初始化语法</a> ，那么你可以使用属性初始值设置来正确地 绑定(bind) 回调：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这个语法确保 `this` 绑定在 handleClick 中。</span></span><br><span class="line">  <span class="comment">// 警告：这是 *实验性的* 语法。</span></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法在  <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建 React App</a>  中是默认开启的。</p><p>如果你没有使用属性初始化语法，可以在回调中使用一个  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 这个语法确保 `this` 被绑定在 handleClick 中</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语法的问题是，每次  <code>LoggingButton</code>  渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。</p><h1 id="条件渲染"><a class="markdownIt-Anchor" href="#条件渲染"></a> 条件渲染</h1><p>在 React 中，你可以创建不同的组件封装你所需要的行为。然后，只渲染它们之中的一些，取决于你的应用的状态。</p><p>React 中的条件渲染就和在 JavaScript 中的条件语句一样。使用 JavaScript 操作符如  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener"><code>if</code></a>  或者<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener">条件操作符</a>来创建渲染当前状态的元素，并且让 React 更新匹配的 UI 。</p><p>思考以下两个组件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要创建一个  <code>Greeting</code>  组件, 用来根据用户是否登录, 判断并显示上述两个组件之一：</p><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// 修改为 isLoggedIn=&#123;true&#125; 试试:</span></span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;<span class="literal">false</span>&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ZpVxNq?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这个例子根据  <code>isLoggedIn</code> prop 渲染了不同的问候语 。</p><h3 id="元素变量"><a class="markdownIt-Anchor" href="#元素变量"></a> 元素变量</h3><p>你可以用变量来存储元素。这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</p><p>思考以下两个新组件，分别用于显示登出和登入按钮：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Login</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function LogoutButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Logout</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的例子中，我们将会创建一个<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#adding-local-state-to-a-class" target="_blank" rel="noopener">有状态组件</a>，叫做  <code>LoginControl</code> 。</p><p>它将渲染  <code>或者</code> ，取决于当前状态。同时渲染前面提到的``  组件:</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginControl</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleLoginClick = <span class="keyword">this</span>.handleLoginClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleLogoutClick = <span class="keyword">this</span>.handleLogoutClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isLoggedIn: <span class="literal">false</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;isLoggedIn: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;isLoggedIn: <span class="literal">false</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    let button = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LoginControl /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>虽然声明一个变量并使用一个  <code>if</code>  语句是一个有条件地渲染组件的好方法，有时你可能想要使用一个更简短的语法。在 JSX 中有几种内联条件的方法，如下所述。</p><h3 id="使用逻辑-操作符的内联-if-用法"><a class="markdownIt-Anchor" href="#使用逻辑-操作符的内联-if-用法"></a> 使用逻辑 &amp;&amp; 操作符的内联 if 用法</h3><p>您可以  <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中嵌入任何表达式</a> ，方法是将其包裹在花括号中。这也包括 JavaScript 逻辑<code>&amp;&amp;</code>  运算符。 它有助于有条件地包含一个元素：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mailbox</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> unreadMessages = props.unreadMessages;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &#123;unreadMessages.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [<span class="string">'React'</span>, <span class="string">'Re: React'</span>, <span class="string">'Re:Re: React'</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/ozJddz?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>它可以正常运行，因为在 JavaScript 中， <code>true &amp;&amp; expression</code>  总是会评估为  <code>expression</code> ，而<code>false &amp;&amp; expression</code>  总是执行为  <code>false</code> 。</p><p>因此，如果条件为  <code>true</code> ，则  <code>&amp;&amp;</code>  后面的元素将显示在输出中。 如果是  <code>false</code>，React 将会忽略并跳过它。</p><h3 id="使用条件操作符的内联-if-else"><a class="markdownIt-Anchor" href="#使用条件操作符的内联-if-else"></a> 使用条件操作符的内联 If-Else</h3><p>另一个用于条件渲染元素的内联方法是使用 JavaScript 的条件操作符  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener"><code>condition ? true : false</code></a> 。</p><p>在下面这个例子中，我们使用它来进行条件渲染一个小的文本块：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user <span class="keyword">is</span> &lt;b&gt;&#123;isLoggedIn ? <span class="string">'currently'</span> : <span class="string">'not'</span>&#125;&lt;/b&gt; logged <span class="keyword">in</span>.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也可以用于更大的表达式，虽然不太明显发生了什么：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = <span class="keyword">this</span>.state.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;<span class="keyword">this</span>.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;<span class="keyword">this</span>.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像 JavaScript 一样，你可以根据你和你的团队认为更易于阅读的方式选择合适的风格。还要记住，无论何时何地，当条件变得太复杂时，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h3 id="防止组件渲染"><a class="markdownIt-Anchor" href="#防止组件渲染"></a> 防止组件渲染</h3><p>在极少数情况下，您可能希望组件隐藏自身，即使它是由另一个组件渲染的。为此，返回<code>null</code>  而不是其渲染输出。</p><p>在下面的例子中，根据名为<code>warn</code>的 prop 值，呈现  `` 。如果 prop 值为  <code>false</code>，则该组件不渲染：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningBanner</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!props.warn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"warning"</span>&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Page extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;showWarning: true&#125;</span></span><br><span class="line"><span class="regexp">    this.handleToggleClick = this.handleToggleClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleToggleClick() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      showWarning: !prevState.showWarning</span></span><br><span class="line"><span class="regexp">    &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.state.showWarning ? <span class="string">'Hide'</span> : <span class="string">'Show'</span>&#125;</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/Xjoqwm?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>从组件的  <code>render</code>  方法返回  <code>null</code>  不会影响组件生命周期方法的触发。 例如，<code>componentWillUpdate</code>  和  <code>componentDidUpdate</code>  仍将被调用。</p><h1 id="列表lists-和-键keys"><a class="markdownIt-Anchor" href="#列表lists-和-键keys"></a> 列表(Lists) 和 键(Keys)</h1><p>首先，让我们回顾一下在 JavaScript 中如何转换列表。</p><p>给定下面的代码，我们使用  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数使  <code>numbers</code>  数组中的元素值翻倍。我们将  <code>map()</code>  返回的新数组分配给变量  <code>doubled</code>，并且打印这个它：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span>d = numbers.map((number) =&gt; number * <span class="number">2</span>);</span><br><span class="line">console.log(<span class="built_in">double</span>d);</span><br></pre></td></tr></table></figure><p>这段代码在控制台中打印为  <code>[2, 4, 6, 8, 10]</code>。</p><p>在 React 中，转换数组为  <a href="http://www.css88.com/react/docs/rendering-elements.html" target="_blank" rel="noopener">元素列表</a>  的方式，和上述方法基本相同。</p><h3 id="多组件渲染"><a class="markdownIt-Anchor" href="#多组件渲染"></a> 多组件渲染</h3><p>可以创建元素集合，并用一对大括号  <code>{}</code> <a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">在 JSX 中直接将其引用</a>即可。</p><p>下面，我们用 JavaScript 的  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a>  函数将  <code>numbers</code>  数组循环处理。对于每一项，我们返回一个  ``  元素。最终，我们将结果元素数组分配给  <code>listItems</code>：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>把整个  <code>listItems</code>  数组包含到一个  ``  元素，并<a href="http://www.css88.com/react/docs/rendering-elements.html#rendering-an-element-into-the-dom" target="_blank" rel="noopener">渲染到 DOM</a>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;listItems&#125;&lt;<span class="regexp">/ul&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/GjPyQr?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>这段代码显示从 1 到 5 的数字列表。</p><h3 id="基本列表组件"><a class="markdownIt-Anchor" href="#基本列表组件"></a> 基本列表组件</h3><p>通常情况下，我们会在一个<a href="http://www.css88.com/react/docs/components-and-props.html" target="_blank" rel="noopener">组件</a>中渲染列表。</p><p>我们可以重构前面的例子到一个组件，它接受一个  <code>numbers</code>  数组，并输出一个元素的无序列表。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="xquery"><span class="built_in">&#123;number</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><span class="xquery">&#123;listItems&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当运行上述代码的时候，将会收到一个警告：a key should be provided for list items（应该为列表元素提供一个键）（愚人码头注 ：CodeOpen 中没有报警告，是因为其示例中使用的是 min 版本的 React，换成非 min 版本的就可以看到）。当创建元素列表时，“key” 是一个你需要包含的特殊字符串属性。我们将在下一节讨论它的重要性。</p><p>我们在  <code>numbers.map()</code>  中赋值一个  <code>key</code>  给我们的列表元素，解决丢失 key 的问题。</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    &lt;li<span class="built_in"> key</span>=<span class="built_in">&#123;number</span>.toString()&#125;&gt;</span><br><span class="line">      <span class="built_in">&#123;number</span>&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><span class="xquery">&#123;listItems&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/jrXYRR?editors=0011" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="键keys"><a class="markdownIt-Anchor" href="#键keys"></a> 键(Keys)</h2><p>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标识：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">    &#123;number&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>挑选 key 最好的方式是使用一个在它的同辈元素中不重复的标识字符串。多数情况你可以使用数据中的 IDs 作为 keys：</p><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">const todoItems = todos.map((todo) =&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=</span></span><span class="template-variable">&#123;todo.id&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;todo.text&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure><p>当要渲染的列表项中没有稳定的 IDs 时，你可以使用数据项的索引值作为 key 的最后选择：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">const todoItems = todos.map((todo, <span class="keyword">index</span>) =&gt;</span><br><span class="line">  // <span class="keyword">Only</span> <span class="keyword">do</span> this <span class="keyword">if</span> items have <span class="keyword">no</span> <span class="keyword">stable</span> IDs</span><br><span class="line">  &lt;li key=&#123;<span class="keyword">index</span>&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果列表项可能被重新排序时，我们不建议使用索引作为 keys，因为这导致一定的性能问题，会很慢。如果感兴趣，你可以阅读一下<a href="http://www.css88.com/react/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener">深入的介绍关于为什么 keys 是必须的</a>。</p><h3 id="使用-keys-提取组件"><a class="markdownIt-Anchor" href="#使用-keys-提取组件"></a> 使用 keys 提取组件</h3><p>keys 只在数组的上下文中存在意义。</p><p>例如，如果你<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取</a>  一个  <code>ListItem</code>  组件，应该把 key 放置在数组处理的  <code>元素中，不能放在 `ListItem` 组件自身中的</code>  根元素上。</p><p><strong>例子：错误的 key 用法</strong></p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> ListItem(props) &#123;</span><br><span class="line">  const <span class="keyword">value</span> = props.<span class="keyword">value</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    // 错误！不需要在这里指定<span class="built_in"> key</span>：</span><br><span class="line">    &lt;li<span class="built_in"> key</span>=&#123;<span class="keyword">value</span>.toString()&#125;&gt;</span><br><span class="line">      &#123;<span class="keyword">value</span>&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.<span class="keyword">map</span>(<span class="built_in">(number</span>) =&gt;</span><br><span class="line">    // 错误<span class="built_in">！key</span> 应该在这里指定：</span><br><span class="line">    &lt;ListItem <span class="keyword">value</span>=<span class="built_in">&#123;number</span>&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;listItems&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>错误！key 应该在这里指定：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 正确！这里不需要指定 key ：</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 正确！key 应该在这里被指定</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const numbers = [1, 2, 3, 4, 5];</span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;NumberList numbers=&#123;numbers&#125; /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/rthor/pen/QKzJKG?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>一个好的经验准则是元素中调用  <code>map()</code>  需要 keys 。</p><h3 id="keys-在同辈元素中必须是唯一的"><a class="markdownIt-Anchor" href="#keys-在同辈元素中必须是唯一的"></a> keys 在同辈元素中必须是唯一的</h3><p>在数组中使用的 keys 必须在它们的同辈之间唯一。然而它们并不需要全局唯一。我们可以在操作两个不同数组的时候使用相同的 keys ：</p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> Blog(props) &#123;</span><br><span class="line">  const sidebar = (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;props.posts.<span class="keyword">map</span>((post) =&gt;</span></span><br><span class="line"><span class="xquery">        &lt;li<span class="built_in"> key</span>=&#123;post<span class="built_in">.id</span>&#125;</span><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">          </span><span class="xquery">&#123;post.title&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content = props.posts.<span class="keyword">map</span>((post) =&gt;</span><br><span class="line">    &lt;div<span class="built_in"> key</span>=&#123;post<span class="built_in">.id</span>&#125;&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><span class="xquery">&#123;post.title&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="xquery">&#123;post.content&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;sidebar&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="xquery">&#123;content&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const posts = [</span><br><span class="line">  <span class="built_in">&#123;id</span>: <span class="number">1</span>, title: <span class="string">'Hello World'</span>, content: <span class="string">'Welcome to learning React!'</span>&#125;,</span><br><span class="line">  <span class="built_in">&#123;id</span>: <span class="number">2</span>, title: <span class="string">'Installation'</span>, content: <span class="string">'You can install React from npm.'</span>&#125;</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Blog posts=&#123;posts&#125; /&gt;,</span><br><span class="line"> <span class="built_in"> document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/NRZYGN?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>键是 React 的一个内部映射，但其不会传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入。</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> content = posts.map((<span class="keyword">post</span>) =&gt;</span><br><span class="line">  &lt;<span class="keyword">Post</span></span><br><span class="line">    key=&#123;<span class="keyword">post</span>.id&#125;</span><br><span class="line">    id=&#123;<span class="keyword">post</span>.id&#125;</span><br><span class="line">    title=&#123;<span class="keyword">post</span>.title&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的例子中， <code>Post</code>  组件可以读取  <code>props.id</code>，但是不能读取  <code>props.key</code> 。</p><h3 id="在-jsx-中嵌入-map"><a class="markdownIt-Anchor" href="#在-jsx-中嵌入-map"></a> 在 JSX 中嵌入 map()</h3><p>在上面的例子中，我们单独声明了一个  <code>listItems</code>  变量，并在 JSX 中引用了该变量：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>JSX 允许在大括号中<a href="http://www.css88.com/react/docs/introducing-jsx.html#embedding-expressions-in-jsx" target="_blank" rel="noopener">嵌入任何表达式</a>，因此可以 内联  <code>map()</code>  结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">                  value=&#123;number&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/BLvYrB?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>有时这可以产生清晰的代码，但是这个风格也可能被滥用。就像在 JavaScript 中，是否有必要提取一个变量以提高程序的可读性，这取决于你。但是记住，如果  <code>map()</code>  体中有太多嵌套，可能是<a href="http://www.css88.com/react/docs/components-and-props.html#extracting-components" target="_blank" rel="noopener">提取组件</a>的好时机。</p><h1 id="表单forms"><a class="markdownIt-Anchor" href="#表单forms"></a> 表单(Forms)</h1><p>HTML 表单元素与 React 中的其他 DOM 元素有所不同，因为表单元素自然地保留了一些内部状态。例如，这个纯 HTML 表单接受一个单独的 name：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">label</span>&gt;</span><br><span class="line">    Name:</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span> /&gt;</span><br><span class="line">  &lt;/<span class="keyword">label</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br></pre></td></tr></table></figure><p>该表单和 HTML 表单的默认行为一致，当用户提交此表单时浏览器会打开一个新页面。如果你希望 React 中保持这个行为，也可以工作。但是多数情况下，用一个处理表单提交并访问用户输入到表单中的数据的 JavaScript 函数也很方便。实现这一点的标准方法是使用一种称为“受控组件(controlled components)”的技术。</p><h2 id="受控组件controlled-components"><a class="markdownIt-Anchor" href="#受控组件controlled-components"></a> 受控组件(Controlled Components)</h2><p>在 HTML 中，表单元素如  <code>，</code>  和  ``  表单元素通常保持自己的状态，并根据用户输入进行更新。而在 React 中，可变状态一般保存在组件的 state(状态) 属性中，并且只能通过  <a href="http://www.css88.com/react/docs/react-component.html#setstate" target="_blank" rel="noopener"><code>setState()</code></a>  更新。</p><p>我们可以通过使 React 的 state 成为 “单一数据源原则” 来结合这两个形式。然后渲染表单的 React 组件也可以控制在用户输入之后的行为。这种形式，其值由 React 控制的输入表单元素称为“受控组件”。</p><p>例如，如果我们想使上一个例子在提交时记录名称，我们可以将表单写为受控组件：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameForm</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;value: <span class="string">''</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'A name was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/VmmPgp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>设置表单元素的 value 属性之后，其显示值将由 this.state.value 决定，以满足 React 状态的同一数据理念。每次键盘敲击之后会执行 handleChange 方法以更新 React 状态，显示值也将随着用户的输入改变。</p><p>由于  <code>value</code>  属性设置在我们的表单元素上，显示的值总是  <code>this.state.value</code>，以满足 state 状态的同一数据理念。由于  <code>handleChange</code>  在每次敲击键盘时运行，以更新 React state(状态)，显示的值将更新为用户的输入。</p><p>对于受控组件来说，每一次 state(状态) 变化都会伴有相关联的处理函数。这使得可以直接修改或验证用户的输入。比如，如果我们希望强制 name 的输入都是大写字母，可以这样来写<code>handleChange</code>  方法：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">handle<span class="constructor">Change(<span class="params">event</span>)</span> &#123;</span><br><span class="line">  this.set<span class="constructor">State(&#123;<span class="params">value</span>: <span class="params">event</span>.<span class="params">target</span>.<span class="params">value</span>.<span class="params">toUpperCase</span>()</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="textare-标签"><a class="markdownIt-Anchor" href="#textare-标签"></a> textare 标签</h2><p>在 HTML 中，``  元素通过它的子节点定义了它的文本值：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;</span><br><span class="line">  Hello there, this <span class="keyword">is</span> <span class="keyword">some</span> <span class="built_in">text</span> <span class="keyword">in</span> a <span class="built_in">text</span> area</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>在 React 中，<code>的赋值使用 `value` 属性替代。这样一来，表单中</code>  的书写方式接近于单行文本输入框 ：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EssayForm</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">'Please write an essay about your favorite DOM element.'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'An essay was submitted: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;textarea value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>this.state.value</code>  在构造函数中初始化，所以这些文本一开始就出现在文本域中。</p><h2 id="select-标签"><a class="markdownIt-Anchor" href="#select-标签"></a> select 标签</h2><p>在 HTML 中，``  创建了一个下拉列表。例如，这段 HTML 创建一个下拉的口味(flavors)列表：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">option</span> <span class="keyword">value</span>="grapefruit"&gt;Grapefruit&lt;/<span class="keyword">option</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">option</span> <span class="keyword">value</span>="lime"&gt;Lime&lt;/<span class="keyword">option</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">option</span> selected <span class="keyword">value</span>="coconut"&gt;Coconut&lt;/<span class="keyword">option</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">option</span> <span class="keyword">value</span>="mango"&gt;Mango&lt;/<span class="keyword">option</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>注意，Coconut 选项是初始化选中的，因为它的  <code>selected</code>  属性。React 中，并不使用这个<code>selected</code>  属性，而是在根  <code>select</code>  标签中使用了一个  <code>value</code>  属性。这使得受控组件使用更方便，因为你只需要更新一处即可。例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlavorForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">value</span>: <span class="string">'coconut'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">'Your favorite flavor is: '</span> + <span class="keyword">this</span>.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=<span class="string">"grapefruit"</span>&gt;Grapefruit&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="lime"&gt;Lime&lt;/</span>option&gt;</span><br><span class="line">            &lt;option value=<span class="string">"coconut"</span>&gt;Coconut&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            &lt;option value="mango"&gt;Mango&lt;/</span>option&gt;</span><br><span class="line">          &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>label&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/JbbEzX?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>总的来说，这使  <code>，</code>  和  ``  都以类似的方式工作 —— 它们都接受一个  <code>value</code>  属性可以用来实现一个受控组件。</p><h2 id="处理多个输入元素"><a class="markdownIt-Anchor" href="#处理多个输入元素"></a> 处理多个输入元素</h2><p>当您需要处理多个受控的  <code>input</code>  元素时，您可以为每个元素添加一个  <code>name</code>  属性，并且让处理函数根据  <code>event.target.name</code>  的值来选择要做什么。</p><p>例如：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isGoing: <span class="literal">true</span>,</span><br><span class="line">      numberOfGuests: <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.handleInputChange = <span class="keyword">this</span>.handleInputChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target = event.target;</span><br><span class="line">    const value = target.<span class="keyword">type</span> === <span class="symbol">'checkbo</span>x' ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="type">Is</span> going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"isGoing"</span></span><br><span class="line">            <span class="class"><span class="keyword">type</span></span>=<span class="string">"checkbox"</span></span><br><span class="line">            checked=&#123;<span class="keyword">this</span>.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          <span class="type">Number</span> of guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=<span class="string">"numberOfGuests"</span></span><br><span class="line">            <span class="class"><span class="keyword">type</span></span>=<span class="string">"number"</span></span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/gaearon/pen/wgedvV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>注意我们如何使用 ES6<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">计算的属性名称</a>语法来更新与给定输入名称相对应的 state(状态) 键：</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  [<span class="meta">name</span>]: <span class="keyword">value</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码等价于 ES5 代码:</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">var partialState = &#123;&#125;<span class="comment">;</span></span><br><span class="line">partialState[name] = value<span class="comment">;</span></span><br><span class="line">this.setState(partialState)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>此外，由于  <code>setState()</code>  自动<a href="http://www.css88.com/react/docs/state-and-lifecycle.html#state-updates-are-merged" target="_blank" rel="noopener">将部分状态合并到当前状态</a>，所以我们只需要调用更改的部分即可。</p><h2 id="受控组件的替代方案"><a class="markdownIt-Anchor" href="#受控组件的替代方案"></a> 受控组件的替代方案</h2><p>有时使用受控组件有些乏味，因为你需要为每一个可更改的数据提供事件处理器，并通过 React 组件管理所有输入状态。当你将已经存在的代码转换为 React 时，或将 React 应用程序与非 React 库集成时，这可能变得特别烦人。在这些情况下，您可能需要使用<a href="http://www.css88.com/react/docs/uncontrolled-components.html" target="_blank" rel="noopener">不受控的组件</a>，用于实现输入表单的替代技术。</p><h1 id="状态提升lifting-state-up"><a class="markdownIt-Anchor" href="#状态提升lifting-state-up"></a> 状态提升(Lifting State Up)</h1><p>通常情况下，同一个数据的变化需要几个不同的组件来反映。我们建议提升共享的状态到它们最近的祖先组件中。我们看下这是如何运作的。</p><p>在本节，我们将会创建一个温度计算器，用来计算水在一个给定温度下是否会沸腾。</p><p>我们通过一个称为  <code>BoilingVerdict</code>  的组件开始。它接受  <code>celsius</code>（摄氏温度）作为 prop ，并打印是否足以使水沸腾：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.celsius &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would not boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们将会创建一个  <code>Calculator</code>  组件。它渲染一个  ``  让你输入温度，并在<code>this.state.temperature</code>  中保存它的值。</p><p>另外，它会根据当前输入的温度来渲染  <code>BoilingVerdict</code> 。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> Celsius:&lt;/legend&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;temperature&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(temperature)&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/VpZJRZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="添加第二个输入"><a class="markdownIt-Anchor" href="#添加第二个输入"></a> 添加第二个输入</h2><p>我们新的需求是，除了一个摄氏温度输入之外，我们再提供了一个华氏温度输入，并且两者保持自动同步。</p><p>我们可以从  <code>Calculator</code>  中提取一个  <code>TemperatureInput</code>  组件开始。我们将添加一个新的  <code>scale</code>属性，值可能是  <code>&quot;c&quot;</code>  或者  <code>&quot;f&quot;</code> ：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">  c: <span class="string">'Celsius'</span>,</span><br><span class="line">  f: <span class="string">'Fahrenheit'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以修改  <code>Calculator</code>  来渲染两个独立的温度输入：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">TemperatureInput</span> scale=<span class="string">"c"</span> /&gt;</span><br><span class="line">        &lt;<span class="type">TemperatureInput</span> scale=<span class="string">"f"</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/GWKbao?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>我们现在有两个 (input)输入框 了，但是当你输入其中一个温度时，另一个输入并没有更新。这是跟我们的需要不符的：我们希望它们保持同步。</p><p>我们也不能在  <code>Calculator</code>  中显示  <code>BoilingVerdict</code> 。 <code>Calculator</code>  不知道当前的温度，因为它是在  <code>TemperatureInput</code>  中隐藏的。</p><h2 id="编写转换函数"><a class="markdownIt-Anchor" href="#编写转换函数"></a> 编写转换函数</h2><p>首先，我们编写两个函数来在摄氏温度和华氏温度之间转换：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">toCelsius</span>(fahrenheit) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">(fahrenheit</span> - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(celsius) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">(celsius</span> * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数用来转化数字。接下来再编写一个函数用来接收一个字符串  <code>temperature</code>  和一个 转化器函数 作为参数，并返回一个字符串。这个函数用来在两个输入之间进行相互转换。</p><p>对于无效的  <code>temperature</code>  值，它返回一个空字符串，输出结果保留 3 位小数：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">try</span><span class="constructor">Convert(<span class="params">temperature</span>, <span class="params">convert</span>)</span> &#123;</span><br><span class="line">  const input = parse<span class="constructor">Float(<span class="params">temperature</span>)</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Number</span>.</span></span>is<span class="constructor">NaN(<span class="params">input</span>)</span>) &#123;</span><br><span class="line">    return '';</span><br><span class="line">  &#125;</span><br><span class="line">  const output = convert(input);</span><br><span class="line">  const rounded = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>round(output<span class="operator"> * </span><span class="number">1000</span>)<span class="operator"> / </span><span class="number">1000</span>;</span><br><span class="line">  return rounded.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如， <code>tryConvert('abc', toCelsius)</code>  将返回一个空字符串，而  <code>tryConvert('10.22', toFahrenheit)</code>  返回  <code>'50.396'</code> 。</p><h2 id="状态提升lifting-state-up-2"><a class="markdownIt-Anchor" href="#状态提升lifting-state-up-2"></a> 状态提升(Lifting State Up)</h2><p>目前，两个  <code>TemperatureInput</code>  组件都将其值保持在本地状态中：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: ''&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = <span class="keyword">this</span>.state.temperature;</span><br></pre></td></tr></table></figure><p>但是，我们希望这两个输入是相互同步的。当我们更新摄氏温度输入时，华氏温度输入应反映转换后的温度，反之亦然。</p><p>在 React 中，共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。我们将从  <code>TemperatureInput</code>  中移除相关状态本地状态，并将其移动到  <code>Calculator</code>  中。</p><p>如果  <code>Calculator</code>  拥有共享状态，那么它将成为两个输入当前温度的“单一数据来源”。它可以指示他们具有彼此一致的值。由于两个  <code>TemperatureInput</code>  组件的 props 都来自同一个父级<code>Calculator</code>组件，两个输入将始终保持同步。</p><p>让我们一步一步看看这是如何工作的。</p><p>首先，我们将在  <code>TemperatureInput</code>  组件中用  <code>this.props.temperature</code>  替换<code>this.state.temperature</code> 。 现在，我们假装  <code>this.props.temperature</code>  已经存在，虽然我们将来需要从  <code>Calculator</code>  传递过来：</p><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // 之前是: const temperature = this.<span class="keyword">state</span>.temperature;</span><br><span class="line">  const temperature = this.props.temperature;</span><br></pre></td></tr></table></figure><p>我们知道  <a href="http://www.css88.com/react/docs/components-and-props.html#props-are-read-only" target="_blank" rel="noopener">props(属性) 是只读的</a>。 当  <code>temperature</code>  是 本地 state(状态)时， <code>TemperatureInput</code>可以调用  <code>this.setState()</code>  来更改它。 然而，现在  <code>temperature</code>  来自父级作为 prop(属性) ，<code>TemperatureInput</code>  就无法控制它。</p><p>在 React 中，通常通过使组件“受控”的方式来解决。就像 DOM ``一样接受一个  <code>value</code>和一个  <code>onChange</code> prop(属性) ，所以可以定制  <code>TemperatureInput</code>  接受来自其父级  <code>Calculator</code>  的<code>temperature</code>  和  <code>onTemperatureChange</code> 。</p><p>现在，当  <code>TemperatureInput</code>  想要更新其温度时，它就会调用<code>this.props.onTemperatureChange</code>：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">handle<span class="constructor">Change(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 之前是: this.setState(&#123;temperature: e.target.value&#125;);</span></span><br><span class="line">  this.props.on<span class="constructor">TemperatureChange(<span class="params">e</span>.<span class="params">target</span>.<span class="params">value</span>)</span>;</span><br></pre></td></tr></table></figure><p>请注意，自定义组件中的  <code>temperature</code>  或  <code>onTemperatureChange</code> prop(属性) 名称没有特殊的含义。我们可以命名为任何其他名称，像命名他们为  <code>value</code>  和  <code>onChange</code>，是一个常见的惯例。</p><p><code>onTemperatureChange</code> prop(属性) 和  <code>temperature</code> prop(属性) 一起由父级的  <code>Calculator</code>  组件提供。它将通过修改自己的本地 state(状态) 来处理变更，从而通过新值重新渲染两个输入。我们将很快看到新的  <code>Calculator</code>  实现。</p><p>在修改  <code>Calculator</code>  之前，让我们回顾一下对  <code>TemperatureInput</code>  组件的更改。我们已经从中删除了本地 state(状态) ，不是读取<code>this.state.temperature</code> ，我们现在读取<code>this.props.temperature</code> 。当我们想要更改时， 不是调用  <code>this.setState()</code> ，而是调用<code>this.props.onTemperatureChange()</code>， 这将由  <code>Calculator</code>  提供：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:<span class="xml"><span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span></span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>现在我们来看一下  <code>Calculator</code>  组件。</p><p>我们将当前输入的  <code>temperature</code>  和  <code>scale</code>  存储在本地 state(状态) 中。这是我们从输入 “提升” 的 state(状态) ，它将作为两个输入的 “单一数据来源” 。为了渲染两个输入，我们需要知道的所有数据的最小表示。</p><p>例如，如果我们在摄氏度输入框中输入 37 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">temperature</span>: <span class="string">'37'</span>,</span><br><span class="line">  scale: <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们稍后将华氏温度字段编辑为 212 ，则  <code>Calculator</code>  组件的状态将是：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">temperature</span>: <span class="string">'212'</span>,</span><br><span class="line">  scale: <span class="string">'f'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以存储两个输入框的值，但事实证明是不必要的。存储最近更改的输入框的值，以及它所表示的度量衡就够了。然后，我们可以基于当前的  <code>temperature</code>(温度) 和  <code>scale</code>(度量衡) 来推断其他输入的值。</p><p>输入框保持同步，因为它们的值是从相同的 state(状态) 计算出来的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="title">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;temperature: <span class="string">''</span>, scale: <span class="string">'c'</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;scale: <span class="string">'c'</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;scale: <span class="string">'f'</span>, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">    <span class="keyword">const</span> celsius = scale === <span class="string">'f'</span> ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    <span class="keyword">const</span> fahrenheit = scale === <span class="string">'c'</span> ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"c"</span></span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=<span class="string">"f"</span></span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/valscion/pen/jBNjja?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>现在，无论你编辑哪个输入框，<code>Calculator</code>  中的  <code>this.state.temperature</code>  和  <code>this.state.scale</code>都会更新。其中一个输入框获取值，所以任何用户输入都被保留，并且另一个输入总是基于它重新计算值。</p><p>让我们回顾一下编辑输入时会发生什么：</p><ul><li>React 调用在 DOM ``  上的  <code>onChange</code>  指定的函数。在我们的例子中，这是<code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法。</li><li><code>TemperatureInput</code>  组件中的  <code>handleChange</code>  方法使用 新的期望值 调用<code>this.props.onTemperatureChange()</code>。<code>TemperatureInput</code>  组件中的 props(属性) ，包括<code>onTemperatureChange</code>，由其父组件  <code>Calculator</code>  提供。</li><li>当它预先呈现时， <code>Calculator</code>  指定了摄氏  <code>TemperatureInput</code>  的  <code>onTemperatureChange</code>  是<code>Calculator</code>  的  <code>handleCelsiusChange</code>  方法，并且华氏  <code>TemperatureInput</code>  的<code>onTemperatureChange</code>  是  <code>Calculator</code>  的  <code>handleFahrenheitChange</code>  方法。因此，会根据我们编辑的输入框，分别调用这两个  <code>Calculator</code>  方法。</li><li>在这些方法中， <code>Calculator</code>  组件要求 React 通过使用 新的输入值 和 刚刚编辑的输入框的当前度量衡 来调用  <code>this.setState()</code>  来重新渲染自身。</li><li>React 调用  <code>Calculator</code>  组件的  <code>render</code>  方法来了解 UI 外观应该是什么样子。基于当前温度和激活的度量衡来重新计算两个输入框的值。这里进行温度转换。</li><li>React 使用  <code>Calculator</code>  指定的新 props(属性) 调用各个  <code>TemperatureInput</code>  组件的  <code>render</code>方法。 它了解 UI 外观应该是什么样子。</li><li>React DOM 更新 DOM 以匹配期望的输入值。我们刚刚编辑的输入框接收当前值，另一个输入框更新为转换后的温度。</li></ul><p>每个更新都会执行相同的步骤，以便输入保持同步。</p><h2 id="经验总结"><a class="markdownIt-Anchor" href="#经验总结"></a> 经验总结</h2><p>在一个 React 应用中，对于任何可变的数据都应该循序“单一数据源”原则。通常情况下，state 首先被添加到需要它进行渲染的组件。然后，如果其它的组件也需要它，你可以提升状态到它们最近的祖先组件。你应该依赖  <a href="http://www.css88.com/react/docs/state-and-lifecycle.html#the-data-flows-down" target="_blank" rel="noopener">从上到下的数据流向</a> ，而不是试图在不同的组件中同步状态。</p><p>提升状态相对于双向绑定方法需要写更多的“模板”代码，但是有一个好处，它可以更方便的找到和隔离 bugs。由于任何 state(状态) 都 “存活” 在若干的组件中，而且可以分别对其独立修改，所以发生错误的可能大大减少。另外，你可以实现任何定制的逻辑来拒绝或者转换用户输入。</p><p>如果某个东西可以从 props(属性) 或者 state(状态) 得到，那么它可能不应该在 state(状态) 中。例如，我们只保存最后编辑的  <code>temperature</code>  和它的  <code>scale</code>，而不是保存  <code>celsiusValue</code>  和<code>fahrenheitValue</code> 。另一个输入框的值总是在  <code>render()</code>  方法中计算得来的。这使我们对其进行清除和四舍五入到其他字段同时不会丢失用户输入的精度。</p><p>当你看到 UI 中的错误，你可以使用  <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React 开发者工具</a>来检查 props ，并向上遍历树，直到找到负责更新状态的组件。这使你可以跟踪到 bug 的源头：</p><h1 id="组合和继承对比composition-vs-inheritance"><a class="markdownIt-Anchor" href="#组合和继承对比composition-vs-inheritance"></a> 组合和继承对比（Composition vs Inheritance）</h1><p>React 拥有一个强大的组合模型，我们建议使用组合而不是继承以实现代码的重用。</p><p>在本节中，我们将考虑几个问题，即 React 新手经常会使用继承，并展示我们如何通过组合来解决它们。</p><h2 id="包含"><a class="markdownIt-Anchor" href="#包含"></a> 包含</h2><p>一些组件在设计前无法获知自己要使用什么子组件，尤其在  <code>Sidebar</code>  和  <code>Dialog</code>  等通用 “容器” 中比较常见。</p><p>我们建议这种组件使用特别的  <code>children</code> prop 来直接传递 子元素到他们的输出中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这允许其他组件通过嵌套 JSX 传递任意子组件给他们：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WelcomeDialog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        Thank you for visiting our spacecraft!</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/ozqNOV?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>在  <code>JSX 标签中的任何内容被传递到 `FancyBorder` 组件中，作为一个 `children`prop(属性)。由于 `FancyBorder` 渲染 `{props.children}` 到一个</code>  中，传递的元素会呈现在最终的输出中。</p><p>然而这并不常见，有时候，在一个组件中你可能需要多个 “占位符” 。在这种情况下，你可以使用自定义的 prop(属性)，而不是使用  <code>children</code> ：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="SplitPane-right"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;SplitPane</span></span><br><span class="line"><span class="regexp">      left=&#123;</span></span><br><span class="line"><span class="regexp">        &lt;Contacts /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZOJp?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>如  <code>和</code>  等 React 元素本质上也是对象，所以可以将其像其他数据一样作为 props(属性) 传递使用。</p><h2 id="特例"><a class="markdownIt-Anchor" href="#特例"></a> 特例</h2><p>有时候，我们考虑组件作为其它组件的“特殊情况”。例如，我们可能说一个  <code>WelcomeDialog</code>  是<code>Dialog</code>  的一个特殊用例。</p><p>在 React 中，也可以使用组合来实现，一个偏“特殊”的组件渲染出一个偏“通用”的组件，通过 props(属性) 配置它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Dialog</span></span><br><span class="line"><span class="regexp">      title="Welcome"</span></span><br><span class="line"><span class="regexp">      message="Thank you for visiting our spacecraft!" /</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/kkEaOZ?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><p>对于用类定义的组件组合也同样适用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p className="Dialog-message"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.message&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/FancyBorder&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class SignUpDialog extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.handleChange = this.handleChange.bind(this);</span></span><br><span class="line"><span class="regexp">    this.handleSignUp = this.handleSignUp.bind(this);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;login: ''&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Dialog title="Mars Exploration Program"</span></span><br><span class="line"><span class="regexp">              message="How should we refer to you?"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input value=&#123;this.state.login&#125;</span></span><br><span class="line"><span class="regexp">               onChange=&#123;this.handleChange&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">login</span>: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(<span class="string">`Welcome aboard, <span class="subst">$&#123;<span class="keyword">this</span>.state.login&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://codepen.io/gaearon/pen/gwZbYa?editors=0010" target="_blank" rel="noopener">在 CodePen 中尝试</a>。</p><h2 id="如何看待"><a class="markdownIt-Anchor" href="#如何看待"></a> 如何看待？</h2><p>在 Facebook ，我们在千万的组件中使用 React，我们还没有发现任何用例，值得我们建议你用继承层次结构来创建组件。</p><p>使用 props(属性) 和 组合已经足够灵活来明确、安全的定制一个组件的外观和行为。切记，组件可以接受任意的 props(属性) ，包括原始值、React 元素，或者函数。</p><p>如果要在组件之间重用非 UI 功能，我们建议将其提取到单独的 JavaScript 模块中。组件可以导入它并使用该函数，对象或类，而不扩展它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-快速入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#react-快速入门&quot;&gt;&lt;/a&gt; React 快速入门&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/frontend/README/"/>
    <id>https://dunwu.github.io/2019/04/25/frontend/README/</id>
    <published>2019-04-25T03:37:49.756Z</published>
    <updated>2019-04-24T11:49:28.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端技术"><a class="markdownIt-Anchor" href="#前端技术"></a> 前端技术</h1><blockquote><p>🎯 所有配套源码整理归档在 <a href="https://github.com/dunwu/frontend-tutorial" target="_blank" rel="noopener"><strong>frontend-tutorial</strong></a> 项目中。</p></blockquote><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><h3 id="base"><a class="markdownIt-Anchor" href="#base"></a> Base</h3><blockquote><p>前端 web 技术的基石： <code>html</code> + <code>css</code> + <code>js</code></p><ul><li>HTML 定义了网页的内容。</li><li>CSS 定义了网页的样式。</li><li>JavaScript 定义了网页的行为。</li></ul></blockquote><ul><li><a href="base/html.md">Html</a></li><li><a href="base/css.md">Css</a></li><li><a href="base/js.md">Javascript</a></li></ul><h3 id="nodejs-npm-yarn"><a class="markdownIt-Anchor" href="#nodejs-npm-yarn"></a> Nodejs, Npm, Yarn</h3><blockquote><p>Nodejs 和包管理器</p><p>流行： <code>npm</code>, <code>yarn</code></p></blockquote><ul><li><a href="nodejs/nodejs.md">Nodejs</a> - 关键词： <code>nodejs</code>, <code>REPL</code>， <code>require</code>, <code>exports</code></li><li><a href="nodejs/npm.md">Npm</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>npm</code>, <code>cnpm</code>, <code>package.json</code>, <code>node_modules</code></li><li><a href="nodejs/yarn.md">Yarn</a> - 关键词： <code>nodejs</code>, <code>包管理</code>, <code>yarn</code>, <code>yarn.lock</code></li></ul><h3 id="es6-typescript-babel"><a class="markdownIt-Anchor" href="#es6-typescript-babel"></a> ES6, TypeScript, Babel</h3><blockquote><p>下一代 Javascript 语言</p></blockquote><ul><li><a href="es6/ES6.md">ES6</a> - 关键词： <code>ES6</code>, <code>ECMAScript</code>, <code>arrow</code>, <code>this</code>, <code>let</code>, <code>const</code>, <code>class</code>, <code>extends</code>, <code>super</code>, <code>arrow</code> …</li><li><a href="es6/babel.md">Babel</a> - 关键词： <code>babel-cli</code>, <code>.babelrc</code>, <code>preset</code>, <code>polyfill</code></li><li><a href="es6/typescript.md">TypeScript</a> - 关键词： <code>typescript</code>, <code>tsc</code></li></ul><h3 id="bundlers"><a class="markdownIt-Anchor" href="#bundlers"></a> Bundlers</h3><blockquote><p>捆绑资源管理器</p><p>流行： <code>Webpack</code></p></blockquote><ul><li><a href="webpack/webpack.md">Webpack 入门</a></li><li><a href="webpack/concept.md">Webpack 概念</a></li><li><a href="webpack/asset-management.md">Webpack 资源管理</a></li><li><a href="webpack/code-splitting.md">Webpack 代码分离</a></li><li><a href="webpack/development.md">Webpack 开发工具</a></li></ul><h3 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> QA</h3><blockquote><p>静态检查工具、代码格式化工具</p><p>流行： <code>JSLint</code>, <code>JSHint</code>, <code>ESLint</code>, <code>Prettier</code>, <code>Standard</code>, <code>TSlint</code></p></blockquote><ul><li><a href="qa/qa-summary.md">JavaScript QA 工具总结</a></li><li><a href="qa/eslint.md">eslint</a></li></ul><h3 id="mvc-react-vue-angular"><a class="markdownIt-Anchor" href="#mvc-react-vue-angular"></a> MVC - React, Vue, Angular</h3><ul><li><a href="mvc/Angular,React,Vue%E6%AF%94%E8%BE%83.md">Angular,React,Vue 比较</a></li></ul><h4 id="react-技术栈"><a class="markdownIt-Anchor" href="#react-技术栈"></a> React 技术栈</h4><ul><li><a href="mvc/react/react.md">React</a></li></ul><h4 id="vue-技术栈"><a class="markdownIt-Anchor" href="#vue-技术栈"></a> Vue 技术栈</h4><h4 id="angular-技术栈"><a class="markdownIt-Anchor" href="#angular-技术栈"></a> Angular 技术栈</h4><ul><li><a href="mvc/angular/angular.md">Angular</a></li></ul><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端技术&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前端技术&quot;&gt;&lt;/a&gt; 前端技术&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;🎯 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/dunwu/fron
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/java/javatool/build/maven/"/>
    <id>https://dunwu.github.io/2019/04/25/java/javatool/build/maven/</id>
    <published>2019-04-25T01:53:47.314Z</published>
    <updated>2019-04-24T11:49:31.895Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/java/javacore/concurrent/README/"/>
    <id>https://dunwu.github.io/2019/04/25/java/javacore/concurrent/README/</id>
    <published>2019-04-25T01:52:11.639Z</published>
    <updated>2019-04-24T11:49:30.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-并发"><a class="markdownIt-Anchor" href="#java-并发"></a> Java 并发</h1><h2 id="内容目录"><a class="markdownIt-Anchor" href="#内容目录"></a> 内容目录</h2><ul><li><a href="Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86.md">Java 并发面试题集</a></li><li><a href="%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B.md">第一章 并发简介</a></li><li><a href="%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.md">第二章 线程基础</a></li><li><a href="%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.md">第三章 并发机制的底层实现</a></li><li><a href="%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.md">第四章 内存模型</a></li><li><a href="%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8.md">第五章 同步容器和并发容器</a></li><li><a href="%E9%94%81.md">第六章 锁</a></li><li><a href="%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB.md">第七章 原子变量类</a></li><li><a href="%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB.md">第八章 并发工具类</a></li><li><a href="%E7%BA%BF%E7%A8%8B%E6%B1%A0.md">第九章 线程池</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-并发&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-并发&quot;&gt;&lt;/a&gt; Java 并发&lt;/h1&gt;
&lt;h2 id=&quot;内容目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#内容目录&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/bigdata/README/"/>
    <id>https://dunwu.github.io/2019/04/25/bigdata/README/</id>
    <published>2019-04-25T01:50:12.989Z</published>
    <updated>2019-04-24T11:49:18.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数据"><a class="markdownIt-Anchor" href="#大数据"></a> 大数据</h1><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><ul><li><a href="MapReduce.md">MapReduce</a></li><li><a href="HDFS.md">HDFS</a></li><li><a href="YARN.md">YARN</a></li><li><a href="hbase">HBase</a><ul><li><a href="hbase/hbase-cli.md">HBase 命令</a></li><li><a href="hbase/hbase-ops.md">HBase 配置</a></li></ul></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3><p><a href="https://book.douban.com/subject/6523762/" target="_blank" rel="noopener">Hadoop 权威指南</a></p><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数据&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#大数据&quot;&gt;&lt;/a&gt; 大数据&lt;/h1&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; 📝 知识点&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/database/sql/README/"/>
    <id>https://dunwu.github.io/2019/04/25/database/sql/README/</id>
    <published>2019-04-25T01:50:12.742Z</published>
    <updated>2019-04-24T11:49:24.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系型数据库"><a class="markdownIt-Anchor" href="#关系型数据库"></a> 关系型数据库</h1><blockquote><p>关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。</p></blockquote><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><h3 id="通用知识点"><a class="markdownIt-Anchor" href="#通用知识点"></a> 通用知识点</h3><ul><li><a href="sql.md">关系型数据库 SQL 基本语法</a></li><li><a href="%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">关系型数据库基本原理</a></li><li><a href="%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98.md">关系型数据库面试题</a></li></ul><h3 id="关系型数据库管理系统rdbms"><a class="markdownIt-Anchor" href="#关系型数据库管理系统rdbms"></a> 关系型数据库管理系统（RDBMS）</h3><ul><li><a href="mysql">Mysql</a></li><li>Oracle</li><li>SQL Server</li><li><a href="postgresql.md">PostgreSQL</a></li><li><a href="sqlite">SQLite</a></li><li>DB2</li><li><a href="h2.md">H2</a></li></ul><h3 id="流行数据库中间件"><a class="markdownIt-Anchor" href="#流行数据库中间件"></a> 流行数据库中间件</h3><ul><li><a href="middleware/flyway.md">flyway</a></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关系型数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#关系型数据库&quot;&gt;&lt;/a&gt; 关系型数据库&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/database/nosql/README/"/>
    <id>https://dunwu.github.io/2019/04/25/database/nosql/README/</id>
    <published>2019-04-25T01:50:12.488Z</published>
    <updated>2019-04-24T11:49:21.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非关系型数据库"><a class="markdownIt-Anchor" href="#非关系型数据库"></a> 非关系型数据库</h1><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><h3 id="非关系型数据库管理系统"><a class="markdownIt-Anchor" href="#非关系型数据库管理系统"></a> 非关系型数据库管理系统</h3><ul><li><a href="redis">Redis</a></li><li><a href="mongodb">MongoDB</a></li><li><a href="Cassandra.md">Cassandra</a></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;非关系型数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#非关系型数据库&quot;&gt;&lt;/a&gt; 非关系型数据库&lt;/h1&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#知识点&quot;&gt;&lt;/a&gt; �
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/04/25/database/README/"/>
    <id>https://dunwu.github.io/2019/04/25/database/README/</id>
    <published>2019-04-25T01:50:12.456Z</published>
    <updated>2019-04-24T11:49:23.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1><blockquote><p>🎯 所有配套源码整理归档在 <a href="https://github.com/dunwu/db-tutorial" target="_blank" rel="noopener"><strong>db-tutorial</strong></a> 项目中。</p></blockquote><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><ul><li><a href="sql">关系型数据库</a></li><li><a href="nosql">非关系型数据库</a></li></ul><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据库&quot;&gt;&lt;/a&gt; 数据库&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;🎯 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/dunwu/db-tuto
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title>Java 通用工具包</title>
    <link href="https://dunwu.github.io/2019/04/16/java/javalib/java-util/"/>
    <id>https://dunwu.github.io/2019/04/16/java/javalib/java-util/</id>
    <published>2019-04-16T09:32:00.000Z</published>
    <updated>2019-04-24T11:49:31.421Z</updated>
    
    <content type="html"><![CDATA[<ul><li>apache.commons<ul><li><a href="https://github.com/apache/commons-lang" target="_blank" rel="noopener">commons-lang</a></li><li><a href="https://github.com/apache/commons-collections" target="_blank" rel="noopener">commons-collections</a></li><li><a href="https://github.com/apache/commons-io" target="_blank" rel="noopener">common-io</a></li></ul></li><li><a href="https://github.com/google/guava" target="_blank" rel="noopener">guava</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;apache.commons
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apache/commons-lang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;commons-lang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://dunwu.github.io/categories/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/categories/java/javalib/"/>
    
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/tags/javalib/"/>
    
  </entry>
  
  <entry>
    <title>reflections</title>
    <link href="https://dunwu.github.io/2019/04/16/java/javalib/reflections/"/>
    <id>https://dunwu.github.io/2019/04/16/java/javalib/reflections/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-24T11:49:31.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reflections"><a class="markdownIt-Anchor" href="#reflections"></a> reflections</h1><p>引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.reflections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reflections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>典型应用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reflections reflections = <span class="keyword">new</span> Reflections(<span class="string">"my.project"</span>);</span><br><span class="line">Set&lt;Class&lt;? extends SomeType&gt;&gt; subTypes = reflections.getSubTypesOf(SomeType.class);</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; annotated = reflections.getTypesAnnotatedWith(SomeAnnotation.class);</span><br></pre></td></tr></table></figure><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p>基本上，使用 Reflections 首先使用 urls 和 scanners 对其进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//scan urls that contain 'my.package', include inputs starting with 'my.package', use the default scanners</span></span><br><span class="line">Reflections reflections = <span class="keyword">new</span> Reflections(<span class="string">"my.package"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or using ConfigurationBuilder</span></span><br><span class="line"><span class="keyword">new</span> Reflections(<span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">     .setUrls(ClasspathHelper.forPackage(<span class="string">"my.project.prefix"</span>))</span><br><span class="line">     .setScanners(<span class="keyword">new</span> SubTypesScanner(),</span><br><span class="line">                  <span class="keyword">new</span> TypeAnnotationsScanner().filterResultsBy(optionalFilter), ...),</span><br><span class="line">     .filterInputsBy(<span class="keyword">new</span> FilterBuilder().includePackage(<span class="string">"my.project.prefix"</span>))</span><br><span class="line">     ...);</span><br></pre></td></tr></table></figure><p>然后，使用方便的查询方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类型扫描</span></span><br><span class="line">Set&lt;Class&lt;? extends Module&gt;&gt; modules =</span><br><span class="line">    reflections.getSubTypesOf(com.google.inject.Module.class);</span><br><span class="line"><span class="comment">// 类型注解扫描</span></span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; singletons =</span><br><span class="line">    reflections.getTypesAnnotatedWith(javax.inject.Singleton.class);</span><br><span class="line"><span class="comment">// 资源扫描</span></span><br><span class="line">Set&lt;String&gt; properties =</span><br><span class="line">    reflections.getResources(Pattern.compile(<span class="string">".*\\.properties"</span>));</span><br><span class="line"><span class="comment">// 方法注解扫描</span></span><br><span class="line">Set&lt;Method&gt; resources =</span><br><span class="line">    reflections.getMethodsAnnotatedWith(javax.ws.rs.Path.class);</span><br><span class="line">Set&lt;Constructor&gt; injectables =</span><br><span class="line">    reflections.getConstructorsAnnotatedWith(javax.inject.Inject.class);</span><br><span class="line"><span class="comment">// 字段注解扫描</span></span><br><span class="line">Set&lt;Field&gt; ids =</span><br><span class="line">    reflections.getFieldsAnnotatedWith(javax.persistence.Id.class);</span><br><span class="line"><span class="comment">// 方法参数扫描</span></span><br><span class="line">Set&lt;Method&gt; someMethods =</span><br><span class="line">    reflections.getMethodsMatchParams(<span class="keyword">long</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">Set&lt;Method&gt; voidMethods =</span><br><span class="line">    reflections.getMethodsReturn(<span class="keyword">void</span>.class);</span><br><span class="line">Set&lt;Method&gt; pathParamMethods =</span><br><span class="line">    reflections.getMethodsWithAnyParamAnnotated(PathParam.class);</span><br><span class="line"><span class="comment">// 方法参数名扫描</span></span><br><span class="line">List&lt;String&gt; parameterNames =</span><br><span class="line">    reflections.getMethodParamNames(Method.class)</span><br><span class="line"><span class="comment">// 方法使用扫描</span></span><br><span class="line">Set&lt;Member&gt; usages =</span><br><span class="line">    reflections.getMethodUsages(Method.class)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>如果未配置扫描程序，则将使用默认值 - SubTypesScanner 和 TypeAnnotationsScanner。</li><li>还可以配置类加载器，它将用于从名称中解析运行时类。</li><li>Reflection 默认情况下会扩展超类型。 这解决了传输 URL 不被扫描的一些问题。</li></ul><h2 id="reflectionutils"><a class="markdownIt-Anchor" href="#reflectionutils"></a> ReflectionUtils</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.reflections.ReflectionUtils.*;</span><br><span class="line"></span><br><span class="line">Set&lt;Method&gt; getters = getAllMethods(someClass,</span><br><span class="line">  withModifier(Modifier.PUBLIC), withPrefix(<span class="string">"get"</span>), withParametersCount(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">Set&lt;Method&gt; listMethodsFromCollectionToBoolean = </span><br><span class="line">  getAllMethods(List.class,</span><br><span class="line">    withParametersAssignableTo(Collection.class), withReturnType(<span class="keyword">boolean</span>.class));</span><br><span class="line"></span><br><span class="line">Set&lt;Field&gt; fields = getAllFields(SomeClass.class, withAnnotation(annotation), withTypeAssignableTo(type));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;reflections&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reflections&quot;&gt;&lt;/a&gt; reflections&lt;/h1&gt;
&lt;p&gt;引入&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解 Java 基本数据类型</title>
    <link href="https://dunwu.github.io/2019/04/06/database/nosql/redis/README/"/>
    <id>https://dunwu.github.io/2019/04/06/database/nosql/redis/README/</id>
    <published>2019-04-06T11:45:00.000Z</published>
    <updated>2019-04-24T11:49:21.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a><ul><li><a href="#redis-%E7%AE%80%E4%BB%8B">Redis 简介</a></li><li><a href="#redis-%E7%9A%84%E4%BC%98%E5%8A%BF">Redis 的优势</a></li><li><a href="#redis-%E4%B8%8E-memcached">Redis 与 Memcached</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li><li><a href="#%E5%91%BD%E4%BB%A4">命令</a><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4">字符串命令</a></li><li><a href="#%E5%88%97%E8%A1%A8%E5%91%BD%E4%BB%A4">列表命令</a></li><li><a href="#%E9%9B%86%E5%90%88%E5%91%BD%E4%BB%A4">集合命令</a></li><li><a href="#%E6%95%A3%E5%88%97%E5%91%BD%E4%BB%A4">散列命令</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%91%BD%E4%BB%A4">有序集合命令</a></li><li><a href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4">发布与订阅命令</a></li><li><a href="#%E5%85%B6%E5%AE%83%E5%91%BD%E4%BB%A4">其它命令</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li><li><a href="#redis-%E7%AE%A1%E9%81%93">Redis 管道</a></li><li><a href="#%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">键的过期时间</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">数据淘汰策略</a></li><li><a href="#%E6%8C%81%E4%B9%85%E5%8C%96">持久化</a><ul><li><a href="#%E5%BF%AB%E7%85%A7%E6%8C%81%E4%B9%85%E5%8C%96">快照持久化</a></li><li><a href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96">AOF 持久化</a></li></ul></li><li><a href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85">发布与订阅</a></li><li><a href="#%E4%BA%8B%E5%8A%A1">事务</a><ul><li><a href="#exec">EXEC</a></li><li><a href="#multi">MULTI</a></li><li><a href="#discard">DISCARD</a></li><li><a href="#watch">WATCH</a></li></ul></li><li><a href="#%E4%BA%8B%E4%BB%B6">事件</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6">文件事件</a></li><li><a href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6">时间事件</a></li><li><a href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C">事件的调度与执行</a></li></ul></li><li><a href="#%E9%9B%86%E7%BE%A4">集群</a><ul><li><a href="#%E5%A4%8D%E5%88%B6">复制</a></li><li><a href="#%E5%93%A8%E5%85%B5">哨兵</a></li><li><a href="#%E5%88%86%E7%89%87">分片</a></li></ul></li><li><a href="#%E8%B5%84%E6%96%99">资料</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><h3 id="redis-简介"><a class="markdownIt-Anchor" href="#redis-简介"></a> Redis 简介</h3><p>Redis 是一个速度非常快的非关系型数据库（NoSQL）。</p><p>Redis 可以存储键（key）和 5 种不同类型的值（value）之间的映射（mapping）。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h3 id="redis-的优势"><a class="markdownIt-Anchor" href="#redis-的优势"></a> Redis 的优势</h3><ul><li>性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s。</li><li>丰富的数据类型 - 支持字符串、列表、集合、有序集合、散列表。</li><li>原子 - Redis 的所有操作都是原子性的。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li><li>持久化 - Redis 支持数据的持久化。可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>备份 - Redis 支持数据的备份，即 master-slave 模式的数据备份。</li><li>丰富的特性 - Redis 还支持发布订阅, 通知, key 过期等等特性。</li></ul><h3 id="redis-与-memcached"><a class="markdownIt-Anchor" href="#redis-与-memcached"></a> Redis 与 Memcached</h3><p>Redis 与 Memcached 因为都可以用于缓存，所以常常被拿来做比较，二者主要有以下区别：</p><p><strong>数据类型</strong></p><ul><li>Memcached 仅支持字符串类型；</li><li>而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。</li></ul><p><strong>数据持久化</strong></p><ul><li>Memcached 不支持持久化；</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li></ul><p><strong>分布式</strong></p><ul><li>Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul><p><strong>内存管理机制</strong></p><ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。</li></ul><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><blockquote><p>扩展阅读：<a href="http://redisinaction.com/preview/chapter1.html#id7" target="_blank" rel="noopener">《Redis 实战》之 Redis 数据结构简介</a></p></blockquote><p>Redis 可以存储键与 5 种不同数据结构类型之间的映射，这 5 种数据结构类型分别为<code>STRING</code>（字符串）、<code>LIST</code>（列表）、<code>SET</code>（集合）、<code>HASH</code>（散列）和<code>ZSET</code>（有序集合）。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1554544262008.png"></div><h2 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h2><blockquote><p>更详细内容可以阅读：</p><ul><li><a href="http://redisinaction.com/preview/chapter3.html" target="_blank" rel="noopener">《Redis 实战》之 Redis 命令</a></li><li><a href="https://redis.io/commands" target="_blank" rel="noopener">Redis 官方命令手册</a></li></ul></blockquote><h3 id="字符串命令"><a class="markdownIt-Anchor" href="#字符串命令"></a> 字符串命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>INCR</code></td><td style="text-align:left"><code>INCR key-name</code>——将键存储的值加上 1</td></tr><tr><td style="text-align:left"><code>DECR</code></td><td style="text-align:left"><code>DECR key-name</code>——将键存储的值减去 1</td></tr><tr><td style="text-align:left"><code>INCRBY</code></td><td style="text-align:left"><code>INCRBY key-name amount</code>——将键存储的值加上整数<code>amount</code></td></tr><tr><td style="text-align:left"><code>DECRBY</code></td><td style="text-align:left"><code>DECRBY key-name amount</code>——将键存储的值减去整数<code>amount</code></td></tr><tr><td style="text-align:left"><code>INCRBYFLOAT</code></td><td style="text-align:left"><code>INCRBYFLOAT key-name amount</code>——将键存储的值加上浮点数<code>amount</code>，这个命令在 Redis 2.6 或以上的版本可用</td></tr><tr><td style="text-align:left"><code>APPEND</code></td><td style="text-align:left"><code>APPEND key-name value</code>——将提供的值<code>value</code>追加到给定键<code>key-name</code>当前存储的值的末尾</td></tr><tr><td style="text-align:left"><code>GETRANGE</code></td><td style="text-align:left"><code>GETRANGE key-name start end</code>——获取一个由偏移量<code>start</code>至偏移量<code>end</code>范围内所有字符组成的子串，包括<code>start</code>和<code>end</code>在内</td></tr><tr><td style="text-align:left"><code>SETRANGE</code></td><td style="text-align:left"><code>SETRANGE key-name offset value</code>——将从<code>start</code>偏移量开始的子串设置为给定<code>value</code></td></tr><tr><td style="text-align:left"><code>GETBIT</code></td><td style="text-align:left"><code>GETBIT key-name offset</code>——将字节串看作是二进制位串（bit string），并返回位串中偏移量为<code>offset</code>的二进制位的值</td></tr><tr><td style="text-align:left"><code>SETBIT</code></td><td style="text-align:left"><code>SETBIT key-name offset value</code>——将字节串看作是二进制位串，并将位串中偏移量为<code>offset</code>的二进制位的值设置为<code>value</code></td></tr><tr><td style="text-align:left"><code>BITCOUNT</code></td><td style="text-align:left"><code>BITCOUNT key-name [start end]</code>——统计二进制位串里面值为 1 的二进制位的数量，如果给定了可选的<code>start</code>偏移量和<code>end</code>偏移量，那么只对偏移量指定范围内的二进制位进行统计</td></tr><tr><td style="text-align:left"><code>BITOP</code></td><td style="text-align:left"><code>BITOP operation dest-key key-name [key-name ...]</code>——对一个或多个二进制位串执行包括并（<code>AND</code>）、或（<code>OR</code>）、异或（<code>XOR</code>）、 非（<code>NOT</code>）在内的任意一种按位运算操作（bitwise operation），并将计算得出的结果保存在<code>dest-key</code>键里面</td></tr></tbody></table><h3 id="列表命令"><a class="markdownIt-Anchor" href="#列表命令"></a> 列表命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>RPUSH</code></td><td style="text-align:left"><code>RPUSH key-name value [value ...]</code>——将一个或多个值推入到列表的右端</td></tr><tr><td style="text-align:left"><code>LPUSH</code></td><td style="text-align:left"><code>LPUSH key-name value [value ...]</code>——将一个或多个值推入到列表的左端</td></tr><tr><td style="text-align:left"><code>RPOP</code></td><td style="text-align:left"><code>RPOP key-name</code>——移除并返回列表最右端的元素</td></tr><tr><td style="text-align:left"><code>LPOP</code></td><td style="text-align:left"><code>LPOP key-name</code>——移除并返回列表最左端的元素</td></tr><tr><td style="text-align:left"><code>LINDEX</code></td><td style="text-align:left"><code>LINDEX key-name offset</code>——返回列表中偏移量为<code>offset</code>的元素</td></tr><tr><td style="text-align:left"><code>LRANGE</code></td><td style="text-align:left"><code>LRANGE key-name start end</code>——返回列表从<code>start</code>偏移量到<code>end</code>偏移量范围内的所有元素，包括<code>start</code>和<code>end</code></td></tr><tr><td style="text-align:left"><code>LTRIM</code></td><td style="text-align:left"><code>LTRIM key-name start end</code>——对列表进行修剪，只保留从<code>start</code>偏移量到<code>end</code>偏移量范围内的元素，包括<code>start</code>和<code>end</code></td></tr><tr><td style="text-align:left"><code>BLPOP</code></td><td style="text-align:left"><code>BLPOP key-name [key-name ...] timeout</code>——从第一个非空列表中弹出位于最左端的元素，或者在<code>timeout</code>秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left"><code>BRPOP</code></td><td style="text-align:left"><code>BRPOP key-name [key-name ...] timeout</code>——从第一个非空列表中弹出位于最右端的元素，或者在<code>timeout</code>秒之内阻塞并等待可弹出的元素出现</td></tr><tr><td style="text-align:left"><code>RPOPLPUSH</code></td><td style="text-align:left"><code>RPOPLPUSH source-key dest-key</code>——从<code>source-key</code>列表中弹出位于最右端的元素，然后将这个元素推入到<code>dest-key</code>列表的最左端，并向用户返回这个元素</td></tr><tr><td style="text-align:left"><code>BRPOPLPUSH</code></td><td style="text-align:left"><code>BRPOPLPUSH source-key dest-key timeout</code>——从<code>source-key</code>列表中弹出位于最右端的元素，然后将这个元素推入到<code>dest-key</code>列表的最左端， 并向用户返回这个元素；如果<code>source-key</code>为空，那么在<code>timeout</code>秒之内阻塞并等待可弹出的元素出现</td></tr></tbody></table><h3 id="集合命令"><a class="markdownIt-Anchor" href="#集合命令"></a> 集合命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>SADD</code></td><td style="text-align:left"><code>SADD key-name item [item ...]</code>——将一个或多个元素添加到集合里面，并返回被添加元素当中原本并不存在于集合里面的元素数量</td></tr><tr><td style="text-align:left"><code>SREM</code></td><td style="text-align:left"><code>SREM key-name item [item ...]</code>——从集合里面移除一个或多个元素，并返回被移除元素的数量</td></tr><tr><td style="text-align:left"><code>SISMEMBER</code></td><td style="text-align:left"><code>SISMEMBER key-name item</code>——检查元素<code>item</code>是否存在于集合<code>key-name</code>里</td></tr><tr><td style="text-align:left"><code>SCARD</code></td><td style="text-align:left"><code>SCARD key-name</code>——返回集合包含的元素的数量</td></tr><tr><td style="text-align:left"><code>SMEMBERS</code></td><td style="text-align:left"><code>SMEMBERS key-name</code>——返回集合包含的所有元素</td></tr><tr><td style="text-align:left"><code>SRANDMEMBER</code></td><td style="text-align:left"><code>SRANDMEMBER key-name [count]</code>——从集合里面随机地返回一个或多个元素。当<code>count</code>为正数时，命令返回的随机元素不会重复； 当<code>count</code>为负数时，命令返回的随机元素可能会出现重复</td></tr><tr><td style="text-align:left"><code>SPOP</code></td><td style="text-align:left"><code>SPOP key-name</code>——从集合里面移除并返回一个随机元素</td></tr><tr><td style="text-align:left"><code>SMOVE</code></td><td style="text-align:left"><code>SMOVE source-key dest-key item</code>——如果集合<code>source-key</code>包含元素<code>item</code>， 那么从集合<code>source-key</code>里面移除元素<code>item</code>，并将元素<code>item</code>添加到集合<code>dest-key</code>中； 如果<code>item</code>被成功移除，那么命令返回 1，否则返回 0</td></tr><tr><td style="text-align:left"><code>SDIFF</code></td><td style="text-align:left"><code>SDIFF key-name [key-name ...]</code>——返回那些存在于第一个集合、但不存在于其他集合中的元素（数学上的差集运算）</td></tr><tr><td style="text-align:left"><code>SDIFFSTORE</code></td><td style="text-align:left"><code>SDIFFSTORE dest-key key-name [key-name ...]</code>——将那些存在于第一个集合、但并不存在于其他集合中的元素（数学上的差集运算）存储到<code>dest-key</code>中</td></tr><tr><td style="text-align:left"><code>SINTER</code></td><td style="text-align:left"><code>SINTER key-name [key-name ...]</code>——返回那些同时存在于所有集合中的元素（数学上的交集运算）</td></tr><tr><td style="text-align:left"><code>SINTERSTORE</code></td><td style="text-align:left"><code>SINTERSTORE dest-key key-name [key-name ...]</code>——将那些同时存在于所有集合的元素（数学上的交集运算）保存到键<code>dest-key</code></td></tr><tr><td style="text-align:left"><code>SUNION</code></td><td style="text-align:left"><code>SUNION key-name [key-name ...]</code>——返回那些至少存在于一个集合中的元素（数学上的并集计算）</td></tr><tr><td style="text-align:left"><code>SUNIONSTORE</code></td><td style="text-align:left"><code>SUNIONSTORE dest-key key-name [key-name ...]</code>——将那些至少存在于一个集合中的元素（数学上的并集计算）存储到<code>dest-key</code>中</td></tr></tbody></table><h3 id="散列命令"><a class="markdownIt-Anchor" href="#散列命令"></a> 散列命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>HMGET</code></td><td style="text-align:left"><code>HMGET key-name key [key ...]</code>——从散列里面获取一个或多个键的值</td></tr><tr><td style="text-align:left"><code>HMSET</code></td><td style="text-align:left"><code>HMSET key-name key value [key value ...]</code>——为散列里面的一个或多个键设置值</td></tr><tr><td style="text-align:left"><code>HDEL</code></td><td style="text-align:left"><code>HDEL key-name key [key ...]</code>——删除散列里面的一个或多个键值对，返回成功找到并删除的键值对数量</td></tr><tr><td style="text-align:left"><code>HLEN</code></td><td style="text-align:left"><code>HLEN key-name</code>——返回散列包含的键值对数量</td></tr><tr><td style="text-align:left"><code>HEXISTS</code></td><td style="text-align:left"><code>HEXISTS key-name key</code>——检查给定键是否存在于散列中</td></tr><tr><td style="text-align:left"><code>HKEYS</code></td><td style="text-align:left"><code>HKEYS key-name</code>——获取散列包含的所有键</td></tr><tr><td style="text-align:left"><code>HVALS</code></td><td style="text-align:left"><code>HVALS key-name</code>——获取散列包含的所有值</td></tr><tr><td style="text-align:left"><code>HGETALL</code></td><td style="text-align:left"><code>HGETALL key-name</code>——获取散列包含的所有键值对</td></tr><tr><td style="text-align:left"><code>HINCRBY</code></td><td style="text-align:left"><code>HINCRBY key-name key increment</code>——将键<code>key</code>保存的值加上整数<code>increment</code></td></tr><tr><td style="text-align:left"><code>HINCRBYFLOAT</code></td><td style="text-align:left"><code>HINCRBYFLOAT key-name key increment</code>——将键<code>key</code>保存的值加上浮点数<code>increment</code></td></tr></tbody></table><h3 id="有序集合命令"><a class="markdownIt-Anchor" href="#有序集合命令"></a> 有序集合命令</h3><table><thead><tr><th><code>ZADD</code></th><th><code>ZADD key-name score member [score member ...]</code>——将带有给定分值的成员添加到有序集合里面</th></tr></thead><tbody><tr><td><code>ZREM</code></td><td><code>ZREM key-name member [member ...]</code>——从有序集合里面移除给定的成员，并返回被移除成员的数量</td></tr><tr><td><code>ZCARD</code></td><td><code>ZCARD key-name</code>——返回有序集合包含的成员数量</td></tr><tr><td><code>ZINCRBY</code></td><td><code>ZINCRBY key-name increment member</code>——将<code>member</code>成员的分值加上<code>increment</code></td></tr><tr><td><code>ZCOUNT</code></td><td><code>ZCOUNT key-name min max</code>——返回分值介于<code>min</code>和<code>max</code>之间的成员数量</td></tr><tr><td><code>ZRANK</code></td><td><code>ZRANK key-name member</code>——返回成员<code>member</code>在<code>key-name</code>中的排名</td></tr><tr><td><code>ZSCORE</code></td><td><code>ZSCORE key-name member</code>——返回成员<code>member</code>的分值</td></tr><tr><td><code>ZRANGE</code></td><td><code>ZRANGE key-name start stop [WITHSCORES]</code>——返回有序集合中排名介于<code>start</code>和<code>stop</code>之间的成员，如果给定了可选的<code>WITHSCORES</code>选项，那么命令会将成员的分值也一并返回</td></tr><tr><td><code>ZREVRANK</code></td><td><code>ZREVRANK key-name member</code>——返回有序集合里成员<code>member</code>所处的位置，成员按照分值从大到小排列</td></tr><tr><td><code>ZREVRANGE</code></td><td><code>ZREVRANGE key-name start stop [WITHSCORES]</code>——返回有序集合给定排名范围内的成员，成员按照分值从大到小排列</td></tr><tr><td><code>ZRANGEBYSCORE</code></td><td><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>——返回有序集合中，分值介于<code>min</code>和<code>max</code>之间的所有成员</td></tr><tr><td><code>ZREVRANGEBYSCORE</code></td><td><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code>——获取有序集合中分值介于<code>min</code>和<code>max</code>之间的所有成员，并按照分值从大到小的顺序来返回它们</td></tr><tr><td><code>ZREMRANGEBYRANK</code></td><td><code>ZREMRANGEBYRANK key-name start stop</code>——移除有序集合中排名介于<code>start</code>和<code>stop</code>之间的所有成员</td></tr><tr><td><code>ZREMRANGEBYSCORE</code></td><td><code>ZREMRANGEBYSCORE key-name min max</code>——移除有序集合中分值介于<code>min</code>和<code>max</code>之间的所有成员</td></tr><tr><td><code>ZINTERSTORE</code></td><td><code>ZINTERSTORE dest-key key-count key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code>——对给定的有序集合执行类似于集合的交集运算</td></tr><tr><td><code>ZUNIONSTORE</code></td><td><code>ZUNIONSTORE dest-key key-count key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code>——对给定的有序集合执行类似于集合的并集运算</td></tr></tbody></table><h3 id="发布与订阅命令"><a class="markdownIt-Anchor" href="#发布与订阅命令"></a> 发布与订阅命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>SUBSCRIBE</code></td><td style="text-align:left"><code>SUBSCRIBE channel [channel ...]</code>——订阅给定的一个或多个频道</td></tr><tr><td style="text-align:left"><code>UNSUBSCRIBE</code></td><td style="text-align:left"><code>UNSUBSCRIBE [channel [channel ...]]</code>——退订给定的一个或多个频道，如果执行时没有给定任何频道，那么退订所有频道</td></tr><tr><td style="text-align:left"><code>PUBLISH</code></td><td style="text-align:left"><code>PUBLISH channel message</code>——向给定频道发送消息</td></tr><tr><td style="text-align:left"><code>PSUBSCRIBE</code></td><td style="text-align:left"><code>PSUBSCRIBE pattern [pattern ...]</code>——订阅与给定模式相匹配的所有频道</td></tr><tr><td style="text-align:left"><code>PUNSUBSCRIBE</code></td><td style="text-align:left"><code>PUNSUBSCRIBE [pattern [pattern ...]]</code>——退订给定的模式，如果执行时没有给定任何模式，那么退订所有模式</td></tr></tbody></table><h3 id="其它命令"><a class="markdownIt-Anchor" href="#其它命令"></a> 其它命令</h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">用例和描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>SORT</code></td><td style="text-align:left"><code>SORT source-key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE dest-key]</code> ——根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序的结果</td></tr><tr><td style="text-align:left"><code>PERSIST</code></td><td style="text-align:left"><code>PERSIST key-name</code>——移除键的过期时间</td></tr><tr><td style="text-align:left"><code>TTL</code></td><td style="text-align:left"><code>TTL key-name</code>——返回给定键距离过期还有多少秒</td></tr><tr><td style="text-align:left"><code>EXPIRE</code></td><td style="text-align:left"><code>EXPIRE key-name seconds</code>——让键<code>key-name</code>在给定的<code>seconds</code>秒之后过期</td></tr><tr><td style="text-align:left"><code>EXPIREAT</code></td><td style="text-align:left"><code>EXPIREAT key-name timestamp</code>——将给定键的过期时间设置为给定的 UNIX 时间戳</td></tr><tr><td style="text-align:left"><code>PTTL</code></td><td style="text-align:left"><code>PTTL key-name</code>——返回给定键距离过期时间还有多少毫秒，这个命令在 Redis 2.6 或以上版本可用</td></tr><tr><td style="text-align:left"><code>PEXPIRE</code></td><td style="text-align:left"><code>PEXPIRE key-name milliseconds</code>——让键<code>key-name</code>在<code>milliseconds</code>毫秒之后过期，这个命令在 Redis 2.6 或以上版本可用</td></tr><tr><td style="text-align:left"><code>PEXPIREAT</code></td><td style="text-align:left"><code>PEXPIREAT key-name timestamp-milliseconds</code>——将一个毫秒级精度的 UNIX 时间戳设置为给定键的过期时间，这个命令在 Redis 2.6 或以上版本可用</td></tr></tbody></table><h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2><ul><li><strong>缓存</strong> - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。</li><li><strong>计数器</strong> - Redis 这种内存数据库能支持计数器频繁的读写操作。</li><li><strong>应用限流</strong> - 限制一个网站访问流量。</li><li><strong>消息队列</strong> - 使用 List 数据类型，它是双向链表。</li><li><strong>查找表</strong> - 使用 HASH 数据类型。</li><li><strong>交集运算</strong> - 使用 SET 类型，例如求两个用户的共同好友。</li><li><strong>排行榜</strong> - 使用 ZSET 数据类型。</li><li><strong>分布式 Session</strong> - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。</li><li><strong>分布式锁</strong> - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。</li></ul><h2 id="redis-管道"><a class="markdownIt-Anchor" href="#redis-管道"></a> Redis 管道</h2><p>Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。</p><p>Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。</p><p>使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理。</p><h2 id="键的过期时间"><a class="markdownIt-Anchor" href="#键的过期时间"></a> 键的过期时间</h2><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><p>可以使用 <code>EXPIRE</code> 或 <code>EXPIREAT</code> 来为 key 设置过期时间。</p><blockquote><p>注意：当 <code>EXPIRE</code> 的时间如果设置的是负数，<code>EXPIREAT</code> 设置的时间戳是过期时间，将直接删除 key。</p></blockquote><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line"><span class="string">"OK"</span></span><br><span class="line">redis&gt; EXPIRE mykey <span class="number">10</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) <span class="number">10</span></span><br><span class="line">redis&gt; SET mykey <span class="string">"Hello World"</span></span><br><span class="line"><span class="string">"OK"</span></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) <span class="number">-1</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure><h2 id="数据淘汰策略"><a class="markdownIt-Anchor" href="#数据淘汰策略"></a> 数据淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超过时施行淘汰策略，具体有 6 种淘汰策略。</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>如果使用 Redis 来缓存数据时，要保证所有数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法（LRU、TTL）实际实现上并非针对所有 key，而是抽样一小部分 key 从中选出被淘汰 key，抽样数量可通过 maxmemory-samples 配置。</p><h2 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h3 id="快照持久化"><a class="markdownIt-Anchor" href="#快照持久化"></a> 快照持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h3 id="aof-持久化"><a class="markdownIt-Anchor" href="#aof-持久化"></a> AOF 持久化</h3><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，然后由操作系统决定什么时候将该内容同步到硬盘，用户可以调用 file.flush() 方法请求操作系统尽快将缓冲区存储的数据同步到硬盘。可以看出写入文件的数据不会立即同步到硬盘上，在将写命令添加到 AOF 文件时，要根据需求来保证何时同步到硬盘上。</p><p>有以下同步选项：</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">同步频率</th></tr></thead><tbody><tr><td style="text-align:center">always</td><td style="text-align:center">每个写命令都同步</td></tr><tr><td style="text-align:center">everysec</td><td style="text-align:center">每秒同步一次</td></tr><tr><td style="text-align:center">no</td><td style="text-align:center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h2 id="发布与订阅"><a class="markdownIt-Anchor" href="#发布与订阅"></a> 发布与订阅</h2><p>订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。</p><p>某个客户端使用 SUBSCRIBE 订阅一个频道，其它客户端可以使用 PUBLISH 向这个频道发送消息。</p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，发布者与订阅者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会去调用观察者的方法；而发布与订阅模式是异步的；</li></ul><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。</p><p>事务可以一次执行多个命令， 并且有以下两个重要的保证：</p><ul><li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul><h3 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> EXEC</h3><p>EXEC 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li><li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</li></ul><h3 id="multi"><a class="markdownIt-Anchor" href="#multi"></a> MULTI</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p><h3 id="discard"><a class="markdownIt-Anchor" href="#discard"></a> DISCARD</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出。</p><p>示例：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&gt; SET foo <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">&gt; GET foo</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure><h3 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> WATCH</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p><p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回 nil-reply 来表示事务已经失败。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = <span class="builtin-name">GET</span> mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line"><span class="builtin-name">SET</span> mykey <span class="variable">$val</span></span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p><p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p><p>WATCH 使得 EXEC 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，如果这个前提不能满足的话，事务就不会被执行。</p><p>WATCH 命令可以被调用多次。对键的监视从 WATCH 执行之后开始生效，直到调用 EXEC 为止。</p><p>用户还可以在单个 WATCH 命令中监视任意多个键，例如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p><p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p><h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2><p>Redis 服务器是一个事件驱动程序。</p><h3 id="文件事件"><a class="markdownIt-Anchor" href="#文件事件"></a> 文件事件</h3><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络时间处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的时间传送给文件事件分派器，分派器会根据套接字产生的事件类型调用响应的时间处理器。</p><h3 id="时间事件"><a class="markdownIt-Anchor" href="#时间事件"></a> 时间事件</h3><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用响应的事件处理器。</p><h3 id="事件的调度与执行"><a class="markdownIt-Anchor" href="#事件的调度与执行"></a> 事件的调度与执行</h3><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能监听太久，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><h2 id="集群"><a class="markdownIt-Anchor" href="#集群"></a> 集群</h2><h3 id="复制"><a class="markdownIt-Anchor" href="#复制"></a> 复制</h3><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h4 id="121-连接过程"><a class="markdownIt-Anchor" href="#121-连接过程"></a> 12.1. 连接过程</h4><ol><li><p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p></li><li><p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p></li><li><p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p></li></ol><h4 id="122-主从链"><a class="markdownIt-Anchor" href="#122-主从链"></a> 12.2. 主从链</h4><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><h3 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵"></a> 哨兵</h3><p>Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h3 id="分片"><a class="markdownIt-Anchor" href="#分片"></a> 分片</h3><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p><p>主要有三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><ul><li>官网<ul><li><a href="https://redis.io/" target="_blank" rel="noopener">redis 官网</a></li><li><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">redis github</a></li></ul></li><li>Sentinel<ul><li><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">官方文档</a> 最全</li><li><a href="http://ifeve.com/redis-sentinel/" target="_blank" rel="noopener">官方文档翻译</a> 翻译,排版一般,新</li><li><a href="http://redisdoc.com/topic/sentinel.html" target="_blank" rel="noopener">官方文档翻译</a> 翻译有段时间了,但主要部分都包含,排版好</li><li><a href="https://blog.csdn.net/yanggd1987/article/details/78364667" target="_blank" rel="noopener">redis sentinel 实战</a> 简要实战,能快速看出来是怎么回事</li></ul></li><li>redis client<ul><li><a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">jedis</a></li><li><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener">redisson</a></li><li><a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="noopener">lettuce</a></li><li><a href="https://docs.spring.io/spring-data/redis/docs/1.8.13.RELEASE/reference/html/" target="_blank" rel="noopener">spring-data-redis 官方文档 </a></li><li><a href="https://www.jianshu.com/p/82f0d5abb002" target="_blank" rel="noopener">CRUG | Redisson PRO vs. Jedis: Which Is Faster? 翻译</a></li><li><a href="https://blog.csdn.net/everlasting_188/article/details/51073505" target="_blank" rel="noopener">redis 分布锁 Redisson 性能测试</a></li></ul></li><li>站点<ul><li><a href="https://github.com/JamzyWang/awesome-redis" target="_blank" rel="noopener">awesome-redis</a></li></ul></li><li>书<ul><li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">Redis 实战</a></li><li><a href="http://redisinaction.com/" target="_blank" rel="noopener">Redis 实战在线版</a></li><li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">Redis 设计与实现</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis&quot;&gt;&lt;/a&gt; Redis&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://github.com/dunwu/blog&quot;
      
    
    </summary>
    
      <category term="database" scheme="https://dunwu.github.io/categories/database/"/>
    
      <category term="nosql" scheme="https://dunwu.github.io/categories/database/nosql/"/>
    
    
      <category term="database" scheme="https://dunwu.github.io/tags/database/"/>
    
      <category term="nosql" scheme="https://dunwu.github.io/tags/nosql/"/>
    
      <category term="redis" scheme="https://dunwu.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>程序员玩转 Windows</title>
    <link href="https://dunwu.github.io/2019/03/22/os/windows/"/>
    <id>https://dunwu.github.io/2019/03/22/os/windows/</id>
    <published>2019-03-22T07:53:00.000Z</published>
    <updated>2019-04-24T11:49:36.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序员玩转-windows"><a class="markdownIt-Anchor" href="#程序员玩转-windows"></a> 程序员玩转 Windows</h1><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E8%BD%AF%E4%BB%B6">软件</a><ul><li><a href="#%E8%A7%86%E9%A2%91%E9%9F%B3%E9%A2%91">视频音频</a></li><li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a></li><li><a href="#%E5%BC%80%E5%8F%91">开发</a></li><li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8">编辑器</a></li><li><a href="#%E6%96%87%E6%A1%A3">文档</a></li><li><a href="#%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87">效率提升</a></li><li><a href="#%E5%8A%9E%E5%85%AC">办公</a></li><li><a href="#%E4%B8%AA%E6%80%A7%E5%8C%96">个性化</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="软件"><a class="markdownIt-Anchor" href="#软件"></a> 软件</h2><blockquote><p>扩展阅读：</p><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">Awesome Windows</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">best-windows-apps</a></li></ul></blockquote><h3 id="视频音频"><a class="markdownIt-Anchor" href="#视频音频"></a> 视频音频</h3><ul><li><a href="http://getmusicbee.com/" target="_blank" rel="noopener">Musicbee</a> - 类似 iTunes，但比 iTunes 更好用。</li><li><a href="http://www.screentogif.com/" target="_blank" rel="noopener">ScreenToGif</a> - 它允许你录制屏幕的一部分区域并保存为 gif 或视频。</li><li><a href="http://potplayer.daum.net/" target="_blank" rel="noopener">PotPlayer</a> - 多媒体播放器，具有广泛的编解码器集合，它还为用户提供大量配置选项。</li><li><a href="http://www.splayer.org/" target="_blank" rel="noopener">射手影音播放器</a> - 来自射手网，小巧开源，首创自动匹配字幕功能。</li></ul><h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3><ul><li><a href="http://www.7-zip.org/" target="_blank" rel="noopener">7-Zip</a> - 用于处理压缩包的开源 Windows 实用程序。完美支持 7z，ZIP，GZIP，BZIP2 和 TAR 的全部特性，其他格式也可解压缩。</li><li><a href="http://www.rarlab.com/" target="_blank" rel="noopener">WinRAR</a> - 强大的归档管理器。 它可以备份您的数据并减小电子邮件附件的大小，解压缩 RAR，ZIP 和其他文件。</li></ul><h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3><ul><li><a href="http://en.ejie.me/" target="_blank" rel="noopener">Clover</a> - 为资源管理器加上多标签功能。</li><li><a href="http://www.ghisler.com/" target="_blank" rel="noopener">Total Commander</a> - 老牌、功能异常强大的文件管理增强软件。</li><li><a href="http://www.softwareok.com/?seite=Freeware/Q-Dir" target="_blank" rel="noopener">Q-Dir</a> - 轻量级的文件管理器，各种布局视图切换灵活，默认四个小窗口组成一个大窗口，操作快捷。软件虽小，粉丝忠诚。</li><li><a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="noopener">WoX</a> - 新一代文件定位工具，堪称 Windows 上的 Alfred。</li><li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a> - 最快的文件/文件夹搜索工具， 通过名称搜索。</li><li><a href="http://www.listary.com/" target="_blank" rel="noopener">Listary</a> - 非常优秀的 Windows 文件浏览和搜索增强工具。</li><li>Beyond Compare - 好用又万能的文件对比工具。</li><li><a href="https://www.piriform.com/ccleaner/download" target="_blank" rel="noopener">CCleaner</a> - 如果你有系统洁癖，那一定要选择一款干净、良心、老牌的清洁软件。</li><li><a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey</a> - 包管理器</li><li><a href="https://ninite.com/" target="_blank" rel="noopener">Ninite</a> - 最简单，最快速的更新或安装软件的方式。</li><li><a href="http://www.piriform.com/RECUVA" target="_blank" rel="noopener">Recuva</a> - 来自 piriform 梨子公司产品，免费的数据恢复工具。</li><li><a href="http://www.launchy.net/" target="_blank" rel="noopener">Launchy</a>：自由的跨平台工具，帮助你忘记开始菜单、桌面图标甚至文件管理器。</li></ul><h3 id="开发"><a class="markdownIt-Anchor" href="#开发"></a> 开发</h3><ul><li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a> - web 调试代理工具。</li><li><a href="https://www.getpostman.com/postman" target="_blank" rel="noopener">Postman</a> - 适合 API 开发的完整工具链，最常用的 REST 客户端。</li><li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> - 一个免费的 Git &amp; Mercurial 客户端。</li><li><a href="https://tortoisesvn.net/" target="_blank" rel="noopener">TortoiseSVN</a> - Subversion(SVN)的图形客户端</li><li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a> - 一个网络协议分析工具。</li><li>Switchhosts</li><li><a href="https://github.com/cmderdev/cmder" target="_blank" rel="noopener">Cmder</a> - 控制台模拟器包。扩展阅读：<a href="https://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/" target="_blank" rel="noopener">Win 下必备神器之 Cmder</a></li><li><a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a> - 基于 Cygwin，用于替代 Windows shell。</li></ul><h3 id="编辑器"><a class="markdownIt-Anchor" href="#编辑器"></a> 编辑器</h3><ul><li><a href="http://www.jetbrains.com/" target="_blank" rel="noopener">JetBrain IDE 系列</a> - 真香！</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> - 用于构建和调试现代 Web 和云应用程序。</li><li><a href="https://eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a> - 一款功能强大的 IDE。</li><li><a href="https://www.visualstudio.com/vs/" target="_blank" rel="noopener">Visual Studio</a> - 微软官方的 IDE，通过插件可支持大量编程语言。</li><li><a href="https://netbeans.org/" target="_blank" rel="noopener">NetBeans IDE</a> - 免费开源的 IDE。</li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> - 个人觉得最好用的 Markdown 编辑器。</li><li><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a> - 跨平台优秀 Markdown 编辑器，本文即用其所写。</li><li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> - 一款支持多种编程语言的源码编辑器。</li><li><a href="http://www.flos-freeware.ch/notepad2.html" target="_blank" rel="noopener">Notepad2</a> - 用于替代默认文本编辑器的轻量快速的编辑器，拥有众多有用的功能。</li><li><a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> - 高级文本编辑器。</li><li><a href="https://atom.io/" target="_blank" rel="noopener">Atom</a> - 面向 21 世纪的极客文本编辑器。</li></ul><h3 id="文档"><a class="markdownIt-Anchor" href="#文档"></a> 文档</h3><ul><li><a href="http://www.office.com/" target="_blank" rel="noopener">Microsoft Office</a> - 微软办公软件。</li><li><a href="https://www.wps.com/office-free" target="_blank" rel="noopener">WPS Office</a> - 金山免费办公软件。</li><li><a href="http://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a> - 用于电子书管理和转换的强大软件。</li><li><a href="http://www.foxitsoftware.cn/products/reader/" target="_blank" rel="noopener">福昕阅读器</a> - 在全球拥有大量用户，最优秀的国产软件之一。Ribbon 界面，支持手写签名、插入印章等。</li></ul><h3 id="效率提升"><a class="markdownIt-Anchor" href="#效率提升"></a> 效率提升</h3><p><strong>【笔记】</strong></p><ul><li><a href="http://www.xmind.net/" target="_blank" rel="noopener">XMind</a> - 优秀的思维导图。</li><li><a href="https://www.onenote.com/" target="_blank" rel="noopener">OneNote</a> - Windows 下综合评价非常高的笔记应用。</li><li><a href="http://www.yinxiang.com/" target="_blank" rel="noopener">印象笔记</a> - 老牌跨平台笔记工具，国际版 Evernote。一家立志于做百年公司的企业，安全、可靠。</li><li><a href="http://www.wiz.cn/index.html" target="_blank" rel="noopener">为知笔记</a> - 越来越好的笔记应用，记录、查阅一切有价值的信息，同样跨平台支持。</li><li><a href="http://note.youdao.com/" target="_blank" rel="noopener">有道云笔记</a> - 网易旗下笔记工具，同样跨主流平台支持，文字、手写、录音、拍照多种记录方式，支持任意附件格式。</li><li><a href="https://getsharex.com/" target="_blank" rel="noopener">ShareX</a> - 你要的所有与截图、录屏相关的功能，这里都有了。</li></ul><p>【快捷键】</p><ul><li><a href="https://autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a> - Windows 平台的终极自动化脚本语言。</li></ul><blockquote><p>技巧：</p><ul><li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/" target="_blank" rel="noopener">https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296" target="_blank" rel="noopener">https://www.autohotkey.com/boards/viewtopic.php?f=29&amp;t=4296</a></li></ul></blockquote><h3 id="办公"><a class="markdownIt-Anchor" href="#办公"></a> 办公</h3><ul><li><a href="http://cidian.youdao.com/index.html" target="_blank" rel="noopener">有道词典</a> - 最好用的免费全能翻译软件。</li><li><a href="http://office.microsoft.com/zh-cn/outlook/" target="_blank" rel="noopener">Outlook</a> - 大名鼎鼎的 Microsoft Office 组件之一，除了电子邮件，还包含了日历、任务管理、联系人、记事本等功能。</li><li><a href="http://www.gmail.com/" target="_blank" rel="noopener">Gmail</a> - 功能上可以称为业界标杆，用户数量世界第一，或许你真的找不到比它更好的邮件系统。</li><li><a href="https://www.google.com/intl/zh-CN/chrome/browser/" target="_blank" rel="noopener">Chrome</a> - 最好的浏览器。</li><li><a href="http://www.teamviewer.com/Zhcn/index.aspx" target="_blank" rel="noopener">Teamviewer</a> - 专业、功能强大的远程控制软件。使用简单，对个人用户免费。</li></ul><h3 id="个性化"><a class="markdownIt-Anchor" href="#个性化"></a> 个性化</h3><ul><li><a href="https://github.com/TranslucentTB/TranslucentTB" target="_blank" rel="noopener">TranslucentTB</a> - 透明化你的 Windows 任务栏。</li><li><a href="http://qttabbar.wikidot.com/" target="_blank" rel="noopener">QTTabBar</a> - 通过多标签和额外的文件夹视图扩展资源管理器的功能。</li><li><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a> - 管理桌面快捷方式。</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/Awesome-Windows/Awesome/blob/master/README-cn.md</a></li><li><a href="https://love.appinn.com/" target="_blank" rel="noopener">https://love.appinn.com/</a></li><li><a href="https://github.com/stackia/best-windows-apps" target="_blank" rel="noopener">https://github.com/stackia/best-windows-apps</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序员玩转-windows&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#程序员玩转-windows&quot;&gt;&lt;/a&gt; 程序员玩转 Windows&lt;/h1&gt;
&lt;!-- TOC depthFrom:2 depthTo:3 --&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="os" scheme="https://dunwu.github.io/categories/os/"/>
    
    
      <category term="os" scheme="https://dunwu.github.io/tags/os/"/>
    
      <category term="windows" scheme="https://dunwu.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的 JSON 应用</title>
    <link href="https://dunwu.github.io/2019/03/18/java/javalib/java-json/"/>
    <id>https://dunwu.github.io/2019/03/18/java/javalib/java-json/</id>
    <published>2019-03-18T03:10:00.000Z</published>
    <updated>2019-04-24T11:49:31.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-中的-json-应用"><a class="markdownIt-Anchor" href="#java-中的-json-应用"></a> Java 中的 JSON 应用</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#json-%E7%AE%80%E4%BB%8B">JSON 简介</a></li><li><a href="#java-json-%E5%BA%93">Java JSON 库</a></li><li><a href="#fastjson">Fastjson</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0-maven-%E4%BE%9D%E8%B5%96">添加 maven 依赖</a></li><li><a href="#javabean-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">JavaBean 的序列化和反序列化</a></li><li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li></ul></li><li><a href="#jackson">Jackson</a><ul><li><a href="#%E6%B7%BB%E5%8A%A0-maven-%E4%BE%9D%E8%B5%96-1">添加 maven 依赖</a></li><li><a href="#api">API</a></li><li><a href="#%E6%B3%A8%E8%A7%A3-1">注解</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="json-简介"><a class="markdownIt-Anchor" href="#json-简介"></a> JSON 简介</h2><p>JSON（JavaScript Object Notation）是一种基于文本的数据交换格式。几乎所有的编程语言都有很好的库或第三方工具来提供基于 JSON 的 API 支持，因此你可以非常方便地使用任何自己喜欢的编程语言来处理 JSON 数据。</p><p>JSON 建构于两种结构：</p><ul><li>“名称/值”对的集合。不同的语言中，它被理解为<em>对象（object）</em>，纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li><li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li></ul><blockquote><p>扩展阅读：</p><ul><li><p><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a> - 图文并茂介绍 json 数据形式</p></li><li><p><a href="http://tools.ietf.org/html/rfc4627" target="_blank" rel="noopener">json 的 RFC 文档</a></p></li></ul></blockquote><h2 id="java-json-库"><a class="markdownIt-Anchor" href="#java-json-库"></a> Java JSON 库</h2><p>Java 中比较流行的 JSON 库有：</p><ul><li><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">Fastjson</a></li><li><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson</a></li><li><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a></li></ul><h2 id="fastjson"><a class="markdownIt-Anchor" href="#fastjson"></a> Fastjson</h2><p><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a> 是阿里巴巴的开源 JSON 解析库。</p><h3 id="添加-maven-依赖"><a class="markdownIt-Anchor" href="#添加-maven-依赖"></a> 添加 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fastjson-api"><a class="markdownIt-Anchor" href="#fastjson-api"></a> Fastjson API</h3><h4 id="javabean-的序列化和反序列化"><a class="markdownIt-Anchor" href="#javabean-的序列化和反序列化"></a> JavaBean 的序列化和反序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String text = JSON.toJSONString(obj); <span class="comment">//序列化</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO.class); <span class="comment">//反序列化</span></span><br></pre></td></tr></table></figure><h3 id="fastjson-注解"><a class="markdownIt-Anchor" href="#fastjson-注解"></a> Fastjson 注解</h3><h4 id="jsonfield"><a class="markdownIt-Anchor" href="#jsonfield"></a> <code>@JSONField</code></h4><p>可以配置在属性（setter、getter）和字段（必须是 public field）上。</p><blockquote><p>扩展阅读：<a href="https://github.com/alibaba/fastjson/wiki/JSONField" target="_blank" rel="noopener">JSONField 用法</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(name=<span class="string">"ID"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> id;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置date序列化和反序列使用yyyyMMdd日期格式</span></span><br><span class="line"><span class="meta">@JSONField</span>(format=<span class="string">"yyyyMMdd"</span>)</span><br><span class="line"><span class="keyword">public</span> Date date1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不序列化</span></span><br><span class="line"><span class="meta">@JSONField</span>(serialize=<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> Date date2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不反序列化</span></span><br><span class="line"><span class="meta">@JSONField</span>(deserialize=<span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> Date date3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按ordinal排序</span></span><br><span class="line"><span class="meta">@JSONField</span>(ordinal = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JSONField</span>(ordinal = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> f2;</span><br></pre></td></tr></table></figure><h4 id="jsontype"><a class="markdownIt-Anchor" href="#jsontype"></a> <code>@JSONType</code></h4><ul><li>自定义序列化：<a href="https://github.com/alibaba/fastjson/wiki/JSONType_serializer" target="_blank" rel="noopener">ObjectSerializer</a></li><li>子类型处理：<a href="https://github.com/alibaba/fastjson/wiki/JSONType_seeAlso_cn" target="_blank" rel="noopener">SeeAlso</a></li></ul><p>JSONType.alphabetic 属性: fastjson 缺省时会使用字母序序列化，如果你是希望按照 java fields/getters 的自然顺序序列化，可以配置 JSONType.alphabetic，使用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONType</span>(alphabetic = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jackson"><a class="markdownIt-Anchor" href="#jackson"></a> Jackson</h2><p>以下仅列举个人认为比较常用的特性。</p><h3 id="添加-maven-依赖-2"><a class="markdownIt-Anchor" href="#添加-maven-依赖-2"></a> 添加 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="jackson-api"><a class="markdownIt-Anchor" href="#jackson-api"></a> Jackson API</h3><blockquote><p>扩展阅读：更多 API 使用细节可以参考 <a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind 官方说明</a></p></blockquote><h4 id="javabean-的序列化和反序列化-2"><a class="markdownIt-Anchor" href="#javabean-的序列化和反序列化-2"></a> JavaBean 的序列化和反序列化</h4><p>反序列化示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">MyValue value = mapper.readValue(<span class="keyword">new</span> File(<span class="string">"data.json"</span>), MyValue.class);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="keyword">new</span> URL(<span class="string">"http://some.com/api/entry.json"</span>), MyValue.class);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">value = mapper.readValue(<span class="string">"&#123;\"name\":\"Bob\", \"age\":13&#125;"</span>, MyValue.class);</span><br></pre></td></tr></table></figure><p>序列化示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper.writeValue(<span class="keyword">new</span> File(<span class="string">"result.json"</span>), myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line"><span class="keyword">byte</span>[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</span><br><span class="line"><span class="comment">// or:</span></span><br><span class="line">String jsonString = mapper.writeValueAsString(myResultObject);</span><br></pre></td></tr></table></figure><h4 id="容器的序列化和反序列化"><a class="markdownIt-Anchor" href="#容器的序列化和反序列化"></a> 容器的序列化和反序列化</h4><figure class="highlight plain"><figcaption><span>扩展阅读：更多 API 使用细节可以参考  [jackson-databind 官方说明](https://github.com/FasterXML/jackson-databind)java</span></figcaption><table><tr><td class="code"><pre><span class="line">Person p = new Person(&quot;Tom&quot;, 20);</span><br><span class="line">Person p2 = new Person(&quot;Jack&quot;, 22);</span><br><span class="line">Person p3 = new Person(&quot;Mary&quot;, 18);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = new LinkedList&lt;&gt;();</span><br><span class="line">persons.add(p);</span><br><span class="line">persons.add(p2);</span><br><span class="line">persons.add(p3);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;persons&quot;, persons);</span><br><span class="line"></span><br><span class="line">String json = null;</span><br><span class="line">try &#123;</span><br><span class="line">json = mapper.writeValueAsString(map);</span><br><span class="line">&#125; catch (JsonProcessingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jackson-注解"><a class="markdownIt-Anchor" href="#jackson-注解"></a> Jackson 注解</h3><blockquote><p>扩展阅读：更多注解使用细节可以参考 <a href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" target="_blank" rel="noopener">jackson-annotations 官方说明</a></p></blockquote><h4 id="jsonproperty"><a class="markdownIt-Anchor" href="#jsonproperty"></a> <code>@JsonProperty</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String _name;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// without annotation, we'd get "theName", but we want "name":</span></span><br><span class="line">   <span class="meta">@JsonProperty</span>(<span class="string">"name"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getTheName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// note: it is enough to add annotation on just getter OR setter;</span></span><br><span class="line">   <span class="comment">// so we can omit it here</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheName</span><span class="params">(String n)</span> </span>&#123; _name = n; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonignoreproperties-和-jsonignore"><a class="markdownIt-Anchor" href="#jsonignoreproperties-和-jsonignore"></a> <code>@JsonIgnoreProperties</code> 和 <code>@JsonIgnore</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// means that if we see "foo" or "bar" in JSON, they will be quietly skipped</span></span><br><span class="line"><span class="comment">// regardless of whether POJO has such properties</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123; <span class="string">"foo"</span>, <span class="string">"bar"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line">   <span class="comment">// will not be written as JSON; nor assigned from JSON:</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">public</span> String internal;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// no annotation, public field is read/written normally</span></span><br><span class="line">   <span class="keyword">public</span> String external;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; _code = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// note: will also be ignored because setter has annotation!</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsoncreator"><a class="markdownIt-Anchor" href="#jsoncreator"></a> <code>@JsonCreator</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorBean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonCreator</span> <span class="comment">// constructor can be public, private, whatever</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">CtorBean</span><span class="params">(@JsonProperty(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">    @<span class="title">JsonProperty</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="jsonpropertyorder"><a class="markdownIt-Anchor" href="#jsonpropertyorder"></a> <code>@JsonPropertyOrder</code></h4><p>alphabetic 设为 true 表示，json 字段按自然顺序排列，默认为 false。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">@JsonPropertyOrder(alphabetic = <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">JacksonAnnotationBean</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a></li><li><a href="http://tools.ietf.org/html/rfc4627" target="_blank" rel="noopener">json 的 RFC 文档</a></li><li><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a></li><li><a href="https://github.com/FasterXML/jackson-docs" target="_blank" rel="noopener">jackson 官方文档</a></li><li><a href="https://github.com/FasterXML/jackson-databind" target="_blank" rel="noopener">jackson-databind</a></li><li><a href="https://kimmking.github.io/2017/06/06/json-best-practice/" target="_blank" rel="noopener">JSON 最佳实践</a></li><li><a href="https://www.jianshu.com/p/8b428e1d1564" target="_blank" rel="noopener">【简明教程】JSON</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-中的-json-应用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-中的-json-应用&quot;&gt;&lt;/a&gt; Java 中的 JSON 应用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;
      
    
    </summary>
    
      <category term="java" scheme="https://dunwu.github.io/categories/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/categories/java/javalib/"/>
    
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javalib" scheme="https://dunwu.github.io/tags/javalib/"/>
    
      <category term="json" scheme="https://dunwu.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Java 常用工具类</title>
    <link href="https://dunwu.github.io/2019/03/14/java/javacore/basics/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://dunwu.github.io/2019/03/14/java/javacore/basics/Java常用工具类/</id>
    <published>2019-03-14T05:02:00.000Z</published>
    <updated>2019-04-24T11:49:29.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-常用工具类"><a class="markdownIt-Anchor" href="#java-常用工具类"></a> Java 常用工具类</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p><p>⌨️ 本文中的示例代码已归档到：「<a href="https://github.com/dunwu/javacore/tree/master/codes/basics/src/main/java/io/github/dunwu/javacore/tool" target="_blank" rel="noopener">javacore</a>」</p><p>并发、IO、容器的工具类不会在本文提及，后面会有专题一一道来。</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a><ul><li><a href="#string">String</a></li><li><a href="#stringbuffer">StringBuffer</a></li><li><a href="#stringbuilder">StringBuilder</a></li></ul></li><li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4">日期时间</a><ul><li><a href="#date">Date</a></li><li><a href="#simpledateformat">SimpleDateFormat</a></li><li><a href="#calendar">Calendar</a></li></ul></li><li><a href="#%E6%95%B0%E5%AD%A6">数学</a><ul><li><a href="#number">Number</a></li><li><a href="#math">Math</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><h3 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h3><h3 id="stringbuilder"><a class="markdownIt-Anchor" href="#stringbuilder"></a> StringBuilder</h3><h2 id="日期时间"><a class="markdownIt-Anchor" href="#日期时间"></a> 日期时间</h2><h3 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h3><h3 id="simpledateformat"><a class="markdownIt-Anchor" href="#simpledateformat"></a> SimpleDateFormat</h3><h3 id="calendar"><a class="markdownIt-Anchor" href="#calendar"></a> Calendar</h3><h2 id="数学"><a class="markdownIt-Anchor" href="#数学"></a> 数学</h2><h3 id="number"><a class="markdownIt-Anchor" href="#number"></a> Number</h3><h3 id="math"><a class="markdownIt-Anchor" href="#math"></a> Math</h3><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java 编程思想</a></li><li><a href="https://book.douban.com/subject/3146174/" target="_blank" rel="noopener">JAVA 核心技术（卷 1）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-常用工具类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-常用工具类&quot;&gt;&lt;/a&gt; Java 常用工具类&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://github.
      
    
    </summary>
    
      <category term="java" scheme="https://dunwu.github.io/categories/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/categories/java/javacore/"/>
    
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/tags/javacore/"/>
    
      <category term="basics" scheme="https://dunwu.github.io/tags/basics/"/>
    
  </entry>
  
  <entry>
    <title>Electron</title>
    <link href="https://dunwu.github.io/2019/03/14/frontend/electron/"/>
    <id>https://dunwu.github.io/2019/03/14/frontend/electron/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-04-24T11:49:27.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="electron"><a class="markdownIt-Anchor" href="#electron"></a> Electron</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:2 --><ul><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%85%A5%E9%97%A8">入门</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><!-- /TOC --><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>Electron 是什么？</p><p>Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 等 Web 技术构建跨平台的应用（兼容 Mac, Windows 和 Linux）。</p><h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2><p>快速启动 应用程序，看看 Electron 是如何运转的：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆示例项目的仓库</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/electron/electron-quick-<span class="literal">start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入这个仓库</span></span><br><span class="line">$ cd electron-quick-<span class="literal">start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖并运行</span></span><br><span class="line">$ npm install &amp;&amp; npm <span class="literal">start</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/electron/electron" target="_blank" rel="noopener">electron</a></li><li><a href="https://electronjs.org/" target="_blank" rel="noopener">electron 官方文档</a></li><li><a href="https://github.com/sindresorhus/awesome-electron" target="_blank" rel="noopener">awesome-electron</a></li><li><a href="https://github.com/electron/electron-quick-start" target="_blank" rel="noopener">electron-quick-start</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;electron&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#electron&quot;&gt;&lt;/a&gt; Electron&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://github.com/du
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础语法特性</title>
    <link href="https://dunwu.github.io/2019/03/10/java/javacore/basics/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/"/>
    <id>https://dunwu.github.io/2019/03/10/java/javacore/basics/Java基础语法特性/</id>
    <published>2019-03-10T14:28:00.000Z</published>
    <updated>2019-04-24T11:49:29.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-基础语法特性"><a class="markdownIt-Anchor" href="#java-基础语法特性"></a> Java 基础语法特性</h1><blockquote><p>📓 本文已归档到：「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">blog</a>」</p></blockquote><!-- TOC depthFrom:2 depthTo:3 --><ul><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li><li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a></li><li><a href="#%E5%8F%98%E9%87%8F">变量</a><ul><li><a href="#%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6">变量修饰符</a></li></ul></li><li><a href="#%E6%95%B0%E7%BB%84">数组</a></li><li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6">操作符</a></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">控制语句</a></li><li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li><li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a></li><li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></li><li><a href="#%E5%8F%8D%E5%B0%84">反射</a></li></ul><!-- /TOC --><h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2><p>空白行，或者注释的内容，都会被 Java 编译器忽略掉。</p><p>Java 支持多种注释方式，下面的示例展示了各种注释的使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JavaDoc 注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">        <span class="comment">/* 多行注释：</span></span><br><span class="line"><span class="comment">           1. 注意点a</span></span><br><span class="line"><span class="comment">           2. 注意点b</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553754196283.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md" target="_blank" rel="noopener">深入理解 Java 基本数据类型</a></p></blockquote><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><p>Java 支持的变量类型有：</p><ul><li><code>局部变量</code> - 类方法中的变量。</li><li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li><li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li></ul><p>特性对比：</p><table><thead><tr><th>局部变量</th><th>实例变量（也叫成员变量）</th><th>类变量（也叫静态变量）</th></tr></thead><tbody><tr><td>局部变量声明在方法、构造方法或者语句块中。</td><td>实例变量声明在方法、构造方法和语句块之外。</td><td>类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。</td></tr><tr><td>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</td><td>实例变量在对象创建的时候创建，在对象被销毁的时候销毁。</td><td>类变量在第一次被访问时创建，在程序结束时销毁。</td></tr><tr><td>局部变量没有默认值，所以必须经过初始化，才可以使用。</td><td>实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</td><td>类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</td></tr><tr><td>对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。</td><td>实例变量存储在堆。</td><td>类变量存储在静态存储区。</td></tr><tr><td>访问修饰符不能用于局部变量。</td><td>访问修饰符可以用于实例变量。</td><td>访问修饰符可以用于类变量。</td></tr><tr><td>局部变量只在声明它的方法、构造方法或者语句块中可见。</td><td>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。</td><td>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</td></tr><tr><td></td><td>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</td><td>静态变量可以通过：ClassName.VariableName 的方式访问。</td></tr><tr><td></td><td></td><td>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</td></tr><tr><td></td><td></td><td>类变量除了被声明为常量外很少使用。</td></tr></tbody></table><h3 id="变量修饰符"><a class="markdownIt-Anchor" href="#变量修饰符"></a> 变量修饰符</h3><ul><li>访问级别修饰符<ul><li>如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）</li></ul></li><li>静态修饰符<ul><li>如果变量是类变量，需要添加 static 修饰</li></ul></li><li>final<ul><li>如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。</li></ul></li></ul><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553753908349.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E6%95%B0%E7%BB%84.md" target="_blank" rel="noopener">深入理解 Java 数组</a></p></blockquote><h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553002212154.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E6%9E%9A%E4%B8%BE.md" target="_blank" rel="noopener">深入理解 Java 数组</a></p></blockquote><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h2><p>Java 中支持的操作符类型如下：</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1552382318465.png"></div><blockquote><p>👉 扩展阅读：<a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">Java 操作符</a></p></blockquote><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553767582595.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">深入理解 Java 方法</a></p></blockquote><h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1552361630220.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.md" target="_blank" rel="noopener">Java 控制语句</a></p></blockquote><h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553752019030.png"></div><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553752795010.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E5%BC%82%E5%B8%B8.md" target="_blank" rel="noopener">深入理解 Java 异常</a></p></blockquote><h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553227663192.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E5%BA%8F%E5%88%97%E5%8C%96.md" target="_blank" rel="noopener">深入理解 Java 序列化</a></p></blockquote><h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553162401292.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E6%B3%9B%E5%9E%8B.md" target="_blank" rel="noopener">深入理解 Java 泛型</a></p></blockquote><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553615203764.png"></div><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/1553615153731.png"></div><blockquote><p>👉 扩展阅读：<a href="https://github.com/dunwu/blog/blob/master/source/_posts/java/javacore/basics/Java%E5%8F%8D%E5%B0%84.md" target="_blank" rel="noopener">深入理解 Java 反射和动态代理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-基础语法特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-基础语法特性&quot;&gt;&lt;/a&gt; Java 基础语法特性&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;📓 本文已归档到：「&lt;a href=&quot;https://gith
      
    
    </summary>
    
      <category term="java" scheme="https://dunwu.github.io/categories/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/categories/java/javacore/"/>
    
    
      <category term="java" scheme="https://dunwu.github.io/tags/java/"/>
    
      <category term="javacore" scheme="https://dunwu.github.io/tags/javacore/"/>
    
      <category term="basics" scheme="https://dunwu.github.io/tags/basics/"/>
    
  </entry>
  
  <entry>
    <title>Title</title>
    <link href="https://dunwu.github.io/2019/03/08/design/architecture/README/"/>
    <id>https://dunwu.github.io/2019/03/08/design/architecture/README/</id>
    <published>2019-03-08T05:16:53.000Z</published>
    <updated>2019-04-24T11:49:24.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构设计"><a class="markdownIt-Anchor" href="#架构设计"></a> 架构设计</h1><p>架构设计是为业务服务，<strong>脱离业务实际的架构设计都是纸上谈兵</strong>。</p><p>架构设计需要根据架构师自身的经验，在实现业务功能、性能、扩展性、系统复杂度等维度上综合考量以及权衡。而架构设计的经验需要架构师不断的学习、不断的积累。性能、扩展性、系统复杂度等方面有很多个专题，有必要针对每个专题由浅入深的去理解、掌握。</p><h2 id="专题"><a class="markdownIt-Anchor" href="#专题"></a> 专题</h2><h2 id="如何设计"><a class="markdownIt-Anchor" href="#如何设计"></a> 如何设计</h2><h3 id="第一步需求分析"><a class="markdownIt-Anchor" href="#第一步需求分析"></a> 第一步：需求分析</h3><p>需求分析阶段，要做的就是<strong>分析使用场景，约束和假设</strong>。</p><p>这个阶段，应该以审视的角度，不断提问、求证，以挖掘用户真实的需求。</p><ul><li>系统是什么？系统有什么功能？</li><li>谁是系统的用户群体？用户群体的规模是多大？</li><li>系统的输入输出分别是什么？</li><li>系统希望处理多少数据？</li><li>系统希望每秒钟处理多少请求？</li><li>系统希望的读写比率？</li></ul><h3 id="第二步概要设计"><a class="markdownIt-Anchor" href="#第二步概要设计"></a> 第二步：概要设计</h3><p>创造一个高层级的设计</p><h3 id="第三步详细设计"><a class="markdownIt-Anchor" href="#第三步详细设计"></a> 第三步：详细设计</h3><ul><li>数据库选型：SQL 还是 NOSQL</li><li>数据库模型</li><li>API 和面向对象设计</li></ul><h3 id="第四步扩展设计"><a class="markdownIt-Anchor" href="#第四步扩展设计"></a> 第四步：扩展设计</h3><ul><li>负载均衡</li><li>水平扩展</li><li>缓存</li><li>数据库分片</li><li>消息队列</li></ul><h2 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h2><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>文章<ul><li><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md" target="_blank" rel="noopener">系统设计入门</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;架构设计&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#架构设计&quot;&gt;&lt;/a&gt; 架构设计&lt;/h1&gt;
&lt;p&gt;架构设计是为业务服务，&lt;strong&gt;脱离业务实际的架构设计都是纸上谈兵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;架构设计需要根据架构师自
      
    
    </summary>
    
      <category term="design" scheme="https://dunwu.github.io/categories/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/categories/design/architecture/"/>
    
    
      <category term="design" scheme="https://dunwu.github.io/tags/design/"/>
    
      <category term="architecture" scheme="https://dunwu.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/algorithm/data-structure/README/"/>
    <id>https://dunwu.github.io/2019/03/06/algorithm/data-structure/README/</id>
    <published>2019-03-06T08:38:10.692Z</published>
    <updated>2019-04-24T11:49:17.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><blockquote><p><code>数据结构</code> 是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。</p><p>记为：<code>Data_Structure=(D,R)</code>。其中 D 是数据元素的集合，R 是该集合中所有元素之间的关系的有限集合。</p></blockquote><ul><li><strong>常用结构</strong><ul><li><a href="array.md">数组</a></li><li><a href="stack.md">栈</a></li><li><a href="queue.md">队列</a></li><li><a href="list.md">链表</a></li><li><a href="tree">树</a> - <a href="tree/tree.md">树</a>、<a href="tree/binary-tree.md">二叉树</a>、<a href="tree/red-black-tree.md">红黑树</a></li><li><a href="graph.md">图</a></li><li><a href="heap.md">堆</a></li><li><a href="hash.md">散列表</a></li></ul></li><li><strong>结构算法</strong><ul><li><a href="search">查找</a></li><li><a href="sort">排序</a> - <a href="sort/bubble-sort.md">冒泡排序</a>、<a href="sort/quick-sort.md">快速排序</a>、<a href="sort/insert-sort.md">直接插入排序</a>、<a href="sort/shell-sort.md">希尔排序</a>、<a href="sort/selection-sort.md">简单选择排序</a>、<a href="sort/heap-sort.md">堆排序</a>、<a href="sort/merge-sort.md">归并排序</a>、<a href="sort/radix-sort.md">基数排序</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据结构&quot;&gt;&lt;/a&gt; 数据结构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;数据结构&lt;/code&gt; 是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dunwu.github.io/2019/03/06/algorithm/README/"/>
    <id>https://dunwu.github.io/2019/03/06/algorithm/README/</id>
    <published>2019-03-06T08:38:10.642Z</published>
    <updated>2019-04-24T11:49:18.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法和数据结构"><a class="markdownIt-Anchor" href="#算法和数据结构"></a> 算法和数据结构</h1><blockquote><p>🎯 所有配套源码整理归档在 <a href="https://github.com/dunwu/algorithm-tutorial" target="_blank" rel="noopener"><strong>algorithm-tutorial</strong></a> 项目中。</p></blockquote><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> 📝 知识点</h2><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><blockquote><p><code>数据结构</code> 是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。</p><p>记为：<code>Data_Structure=(D,R)</code>。其中 D 是数据元素的集合，R 是该集合中所有元素之间的关系的有限集合。</p></blockquote><ul><li><strong>常用结构</strong><ul><li><a href="data-structure/array.md">数组</a></li><li><a href="data-structure/stack.md">栈</a></li><li><a href="data-structure/queue.md">队列</a></li><li><a href="data-structure/list.md">链表</a></li><li><a href="data-structure/tree">树</a> - <a href="data-structure/tree/tree.md">树</a>、<a href="data-structure/tree/binary-tree.md">二叉树</a>、<a href="data-structure/tree/red-black-tree.md">红黑树</a></li><li><a href="data-structure/graph.md">图</a></li><li><a href="data-structure/heap.md">堆</a></li><li><a href="data-structure/hash.md">散列表</a></li></ul></li><li><strong>结构算法</strong><ul><li><a href="data-structure/search">查找</a></li><li><a href="data-structure/sort">排序</a> - <a href="data-structure/sort/bubble-sort.md">冒泡排序</a>、<a href="data-structure/sort/quick-sort.md">快速排序</a>、<a href="data-structure/sort/insert-sort.md">直接插入排序</a>、<a href="data-structure/sort/shell-sort.md">希尔排序</a>、<a href="data-structure/sort/selection-sort.md">简单选择排序</a>、<a href="data-structure/sort/heap-sort.md">堆排序</a>、<a href="data-structure/sort/merge-sort.md">归并排序</a>、<a href="data-structure/sort/radix-sort.md">基数排序</a></li></ul></li></ul><h2 id="学习资源"><a class="markdownIt-Anchor" href="#学习资源"></a> 📚 学习资源</h2><h3 id="书"><a class="markdownIt-Anchor" href="#书"></a> 书</h3><h4 id="刷题必备"><a class="markdownIt-Anchor" href="#刷题必备"></a> 刷题必备</h4><ul><li>《剑指 offer》</li><li>《编程之美》</li><li>《编程之法:面试和算法心得》</li><li>《算法谜题》 都是思维题</li></ul><h4 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h4><ul><li>《<a href="https://www.amazon.cn/gp/product/B00SFZH0DC/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00SFZH0DC&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">编程珠玑（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B0150BMQDM/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0150BMQDM&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">编程珠玑（续）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B01LDG2DSG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01LDG2DSG&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : C++描述（第 4 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NGS&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : C 语言描述（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B01CNP0CG6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B01CNP0CG6&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">数据结构与算法分析 : Java 语言描述（第 2 版）</a>》</li><li>《<a href="https://www.amazon.cn/gp/product/B009OCFQ0O/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B009OCFQ0O&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">算法（第 4 版）</a>》- 这本近千页的书只有 6 章,其中四章分别是排序，查找，图，字符串，足见介绍细致</li></ul><h4 id="算法设计"><a class="markdownIt-Anchor" href="#算法设计"></a> 算法设计</h4><ul><li>《<a href="https://www.amazon.cn/gp/product/B00S4HCQUI/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00S4HCQUI&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">算法设计与分析基础（第 3 版）</a>》</li><li>《算法引论》 - 告诉你如何创造算法 断货</li><li>《Algorithm Design Manual》 - 算法设计手册 红皮书</li><li><a href="https://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B00AK7BYJY&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="noopener">《算法导论》</a> - 是一本对算法介绍比较全面的经典书籍</li><li>《Algorithms on Strings,Trees and Sequences》</li><li>《Advanced Data Structures》 - 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树 600 块</li></ul><h3 id="参考链接和学习网站"><a class="markdownIt-Anchor" href="#参考链接和学习网站"></a> 参考链接和学习网站</h3><ul><li><a href="https://github.com/nonstriater/Learn-Algorithms" target="_blank" rel="noopener">https://github.com/nonstriater/Learn-Algorithms</a></li><li><a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms</a></li><li><a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#数据结构</a></li><li><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="noopener">July 博客</a><ul><li>《数学建模十大经典算法》</li><li>《数据挖掘领域十大经典算法》</li><li>《十道海量数据处理面试题》</li><li>《数字图像处理领域的二十四个经典算法》</li><li>《精选微软等公司经典的算法面试 100 题》</li></ul></li><li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">The-Art-Of-Programming-By-July</a></li><li><a href="http://blog.csdn.net/column/details/ms100.html" target="_blank" rel="noopener">微软面试 100 题</a></li><li><a href="http://blog.csdn.net/v_JULY_v/article/details/6460494" target="_blank" rel="noopener">程序员编程艺术</a></li></ul><h3 id="基本算法演示"><a class="markdownIt-Anchor" href="#基本算法演示"></a> 基本算法演示</h3><ul><li><a href="http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html" target="_blank" rel="noopener">http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html</a></li><li><a href="http://www.cs.usfca.edu/%5C~galles/visualization/Algorithms.html" target="_blank" rel="noopener">http://www.cs.usfca.edu/\~galles/visualization/Algorithms.html</a></li></ul><h3 id="编程网站"><a class="markdownIt-Anchor" href="#编程网站"></a> 编程网站</h3><ul><li><a href="http://leetcode.com/" target="_blank" rel="noopener">leetcode</a></li><li><a href="http://openjudge.cn/" target="_blank" rel="noopener">openjudge</a> 开放在线程序评测平台，可以创建自己的 OJ 小组 <a href="http://ac.jobdu.com/index.php" target="_blank" rel="noopener">九度 OJ</a></li><li>这有个<a href="http://www.java3z.com/cwbwebhome/article/article19/res041.html" target="_blank" rel="noopener">ACM 训练方案</a></li></ul><h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3><ul><li><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/" target="_blank" rel="noopener">高级数据结构和算法</a> 北大教授张铭老师在 coursera 上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie 树、AVL 树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然 coursera 上也还有很多其它算法方面的视频课程。</li><li><a href="https://class.coursera.org/algorithms-001/lecture" target="_blank" rel="noopener">算法设计与分析 Design and Analysis of Algorithms</a> 由北大教授 Wanling Qu 在 coursera 讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf 文件）以便阅读和复习。</li></ul><h2 id="传送门"><a class="markdownIt-Anchor" href="#传送门"></a> 🚪 传送门</h2><p>| <a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">回首頁</a> |</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法和数据结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法和数据结构&quot;&gt;&lt;/a&gt; 算法和数据结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;🎯 所有配套源码整理归档在 &lt;a href=&quot;https://github.com/d
      
    
    </summary>
    
    
      <category term="hide" scheme="https://dunwu.github.io/tags/hide/"/>
    
  </entry>
  
</feed>
